#!/usr/bin/env python3

# (C) 2024  Roger Light <roger@atchoo.org>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

import argparse
import struct
import sys

ansi_reset = "\u001b[0m"
ansi_error = "\u001b[31;7m"
ansi_red = "\u001b[31m"
ansi_green = "\u001b[32m"
ansi_yellow = "\u001b[33m"
ansi_blue = "\u001b[34m"
ansi_magenta = "\u001b[35m"
ansi_cyan = "\u001b[36m"
ansi_white = "\u001b[37m"
ansi_br_black = "\u001b[90m"
ansi_br_red = "\u001b[91m"
ansi_br_green = "\u001b[92m"
ansi_br_yellow = "\u001b[93m"
ansi_br_blue = "\u001b[94m"
ansi_br_magenta = "\u001b[95m"
ansi_br_cyan = "\u001b[96m"
ansi_br_white = "\u001b[97m"
ansi_br_yellow2 = "\u001b[38;5;228m"

connack_strings = {
    0: "accepted",
    1: "refused: protocol version",
    2: "refused: identifier rejected",
    3: "refused: server unavailable",
    4: "refused: bad username or password",
    5: "refused: not authorized",
}

reason_code_strings = {
    0: "success",
    4: "disconnect with will message",
    16: "no matching subscribers",
    17: "no subscription existed",
    24: "continue authentication",
    25: "reauthenticate",
    128: "unspecified",
    129: "malformed packet",
    130: "protocol error",
    131: "implementation specific",
    132: "unsupported protocol version",
    133: "clientid not valid",
    134: "bad username or password",
    135: "not authorized",
    136: "server unavailable",
    137: "server busy",
    138: "banned",
    139: "server shutting down",
    140: "bad authentication method",
    141: "keep alive timeout",
    142: "session taken over",
    143: "topic filter invalid",
    144: "topic name invalid",
    145: "packet id in use",
    146: "packet id not found",
    147: "receive maximum exceeded",
    148: "topic alias invalid",
    149: "packet too large",
    150: "message rate too high",
    151: "quota exceeded",
    152: "administrative action",
    153: "payload format invalid",
    154: "retain not supported",
    155: "qos not supported",
    156: "use another server",
    157: "server moved",
    158: "shared subscriptions not supported",
    159: "connection rate exceeded",
    160: "maximum connection time",
    161: "subscription identifiers not supported",
    162: "wildcard subscriptions not supported",
}

all_props = {
   0x01: ("payload-format-indicator", "byte"),
   0x02: ("message-expiry-interval", "uint32"),
   0x03: ("content-type", "string"),
   0x08: ("response-topic", "string"),
   0x09: ("correlation-data", "string"),
   0x0b: ("subscription-identifier", "varint"),
   0x11: ("session-expiry-interval", "uint32"),
   0x12: ("assigned-client-identifier", "string"),
   0x13: ("server-keep-alive", "uint16"),
   0x15: ("authentication-method", "string"),
   0x16: ("authentication-data", "string"),
   0x17: ("request-problem-information", "byte"),
   0x18: ("will-delay-interval", "uint32"),
   0x19: ("request-response-information", "byte"),
   0x1a: ("response-information", "string"),
   0x1c: ("server-reference", "string"),
   0x1f: ("reason-string", "string"),
   0x21: ("receive-maximum", "uint16"),
   0x22: ("topic-alias-maximum", "uint16"),
   0x23: ("topic-alias", "uint16"),
   0x24: ("maximum-qos", "byte"),
   0x25: ("retain-available", "byte"),
   0x26: ("user-property", "stringpair"),
   0x27: ("maximum-packet-size", "uint32"),
   0x28: ("wildcard-subscription-available", "byte"),
   0x29: ("subscription-identifier-available", "byte"),
   0x2a: ("shared-subscription-available", "byte"),
}

# ============================================================
# OUTPUT COLOURS
# ============================================================
length_colour = ansi_br_magenta
topic_colour = ansi_br_yellow
payload_colour = ansi_br_blue
property_colour = ansi_br_blue
clientid_colour = ansi_br_cyan
keepalive_colour = ansi_br_cyan
cleansession_colour = ansi_br_cyan
protover_colour = ansi_br_cyan
rc_colour = ansi_br_cyan
mid_colour = ansi_br_cyan
qos_colour = ansi_br_cyan
username_colour = ansi_br_cyan
password_colour = ansi_br_cyan
retain_colour = ansi_br_cyan
dup_colour = ansi_br_cyan
sub_opt_colour = ansi_br_cyan
rc_colour = ansi_br_cyan
string_length_colour = ansi_br_yellow2

COMMAND_colour = ansi_yellow
WILL_colour = ansi_br_blue

errstr = f"{ansi_error}?{ansi_reset}"

class mqttdecode():
    def __init__(self, args):
        self.args = args
        pass

    def decode(self, hexstring):
        try:
            self._packet = bytes.fromhex(hexstring)
        except ValueError:
            print(f"Input is not valid hex: {hexstring}")
            return
        while self._packet is not None and len(self._packet) > 0:
            cur_packet = self._packet
            self._decode_packet()
            if self._packet is not None:
                cur_packet = cur_packet[0:len(cur_packet)-len(self._packet)]

            if len(self._output_hex_v4) > 0:
                print(f"Hex:               {self._output_hex_v4}")
                print(self._output_text_v4)

            if len(self._output_hex_v5) > 0:
                print(f"Hex:               {self._output_hex_v5}")
                print(self._output_text_v5)

            if self._packet is not None and len(self._packet) > 0:
                print("------------------------------\n")

    def _save_state(self):
        self._packet_save = self._packet
        self._rl_save = self._rl
        self._output_hex_save = self._output_hex

    def _restore_state(self):
        self._packet = self._packet_save
        self._rl = self._rl_save
        self._output_hex = self._output_hex_save

    def _decode_excess_bytes(self):
        if self._rl == 0:
            return
        if self._packet is not None and len(self._packet) > 0:
            self._output_text += f"Excess bytes:      {ansi_error}{self._packet[0:self._rl].hex()}{ansi_reset}\n"
            self._output_hex += f"{ansi_error}{self._packet[0:self._rl].hex()}{ansi_reset}"
            self._packet = self._packet[self._rl:]
        self._rl = 0


    def _get_output_v4(self):
        self._output_text_v4 = self._output_text
        self._output_hex_v4 = self._output_hex
        self._output_text = ""
        self._output_hex = ""

    def _get_output_v5(self):
        self._output_text_v5 = self._output_text
        self._output_hex_v5 = self._output_hex
        self._output_text = ""
        self._output_hex = ""

    def _decode_byte(self, col):
        if self._rl <= 0:
            return errstr
        try:
            byte = self._packet[0]
            self._output_hex += f"{col}{byte:02x}{ansi_reset} "
            self._packet = self._packet[1:]
        except (IndexError, TypeError):
            byte = errstr
            if len(self._packet) < 1:
                self._packet = None
        self._rl -= 1
        return byte


    def _decode_uint16(self, col):
        if self._rl <= 0:
            return errstr
        try:
            i16 = struct.unpack('!H', self._packet[0:2])[0]
            self._output_hex += f"{col}{self._packet[0:2].hex()}{ansi_reset} "
            self._packet = self._packet[2:]
        except (IndexError, struct.error, TypeError):
            i16 = errstr
            if len(self._packet) < 2:
                self._packet = None
        self._rl -= 2
        return i16


    def _decode_uint32(self, col):
        if self._rl <= 0:
            return errstr
        try:
            i32 = struct.unpack('!I', self._packet[0:4])[0]
            self._output_hex += f"{col}{self._packet[0:4].hex()}{ansi_reset} "
            self._packet = self._packet[4:]
        except (IndexError, struct.error):
            i32 = errstr
            if len(self._packet) < 4:
                self._packet = None
        self._rl -= 4
        return i32


    def _decode_varint(self, col):
        if self._rl <= 0:
            return errstr, 0
        mult = 1
        varint = 0
        vl = 0
        for i in range(0,4):
            if self._rl <= 0:
                return errstr, vl
            try:
                byte = self._packet[0]
                self._packet = self._packet[1:]
                self._output_hex += f"{col}{byte:02x}{ansi_reset} "
            except IndexError:
                varint = errstr
                return (varint, vl)
            self._rl -= 1

            vl += 1
            varint += (byte & 127) * mult
            mult *= 128
            if byte & 128 == 0:
                break

        return (varint, vl)


    def _decode_string(self, col):
        if isinstance(self._rl, str) or self._rl <= 0:
            return errstr, errstr
        slen_full = self._decode_uint16(string_length_colour)
        if isinstance(slen_full, int):
            if slen_full == 0:
                return "", 0
            try:
                slen = min(slen_full, self._rl)
                s = struct.unpack(f'!{slen}s', self._packet[0:slen])[0]
                self._output_hex += f"{col}{self._packet[0:slen].hex()}{ansi_reset} "
                self._rl -= slen
                self._packet = self._packet[slen:]
                s = s.decode('utf-8')
                if slen < slen_full:
                    s += errstr
                return s, slen_full
            except (IndexError, struct.error, UnicodeDecodeError):
                return errstr, errstr
        else:
            return errstr, errstr


    def _decode_properties(self):
        if self._rl <= 0:
            return
        if self._packet is None or len(self._packet) == 0:
            return
        pl, _ = self._decode_varint(property_colour)
        if pl > self._rl:
            self._output_text += f"Properties Length: {ansi_error}{pl} > remaining length{ansi_reset}\n"
            return
        else:
            self._output_text += f"Properties Length: {pl}\n"
        if not isinstance(pl, int):
            return

        while self._rl > 0 and pl > 0:
            prop, vl = self._decode_varint(property_colour)
            pl -= vl

            try:
                propdef = all_props[prop]
            except KeyError:
                self._output_text += f"Property:          Unknown type: {ansi_error}{prop}{ansi_reset}\n"
                return 0, None
            self._output_text += f"Property:          {property_colour}{prop},{propdef[0]} = "
            if propdef[1] == "byte":
                v = self._decode_byte(property_colour)
                pl -= 1
            elif propdef[1] == "uint16":
                v = self._decode_uint16(property_colour)
                pl -= 2
            elif propdef[1] == "uint32":
                v = self._decode_uint32(property_colour)
                pl -= 4
            elif propdef[1] == "varint":
                v, vl = self._decode_varint(property_colour)
                pl -= vl
            elif propdef[1] == "string":
                v, _ = self._decode_string(property_colour)
                pl -= (len(v) + 2)
            elif propdef[1] == "stringpair":
                k, _ = self._decode_string(property_colour)
                v, _ = self._decode_string(property_colour)
                pl -= (len(k) + 2 + len(v) + 2)
                self._output_text += f"{k}:"
            self._output_text += f"{v}{ansi_reset}\n"


    def _decode_mid(self):
        mid = self._decode_uint16(mid_colour)
        if isinstance(mid, int) and mid > 0:
            self._output_text += f"Packet ID:         {mid_colour}{mid}{ansi_reset}\n"
        else:
            self._output_text += f"Packet ID:         {ansi_error}{mid}{ansi_reset}\n"


    def _print_fixed_header(self, expected):
        if self._hdr & 0x0F != expected:
            self._output_text += f"Fixed header:      {ansi_error}0x{self._hdr:02x}{ansi_reset}\n"


    def _print_length(self, rl, expected=-1):
        if isinstance(rl, str):
            self._output_text += f"Length:            {length_colour}{rl}{ansi_reset}\n"
            exit(1)

        if expected == -1 or rl == expected:
            self._output_text += f"Length:            {length_colour}{rl}{ansi_reset}\n"
        else:
            self._output_text += f"Length:            {ansi_error}{rl}{ansi_reset}\n"


    def _print_reason_code(self, rc):
        try:
            rc_str = reason_code_strings[rc]
        except KeyError:
            rc_str = f"{ansi_error}Invalid reason code{ansi_reset}"
        self._output_text += f"Reason code:       {rc_colour}{rc} ({rc_str}){ansi_reset}\n"


    def _decode_reason_code(self):
        rc = self._decode_byte(rc_colour)
        self._print_reason_code(rc)


    def _decode_reserved(self):
        self._output_text += f"Command:           {ansi_error}RESERVED{ansi_reset}\n"
        self._output_hex = f"{ansi_error}{self._hdr:02x}{ansi_reset} " + self._output_hex
        self._print_length(self._rl)
        self._decode_excess_bytes()
        self._get_output_v4()


    def _decode_connect_v34(self, cs_label):
        flags = self._decode_byte(cleansession_colour)
        if isinstance(flags, str):
            return
        username_flag = (flags & 0x80) == 0x80
        password_flag = (flags & 0x40) == 0x40
        will_retain = (flags & 0x20) == 0x20
        will_qos = (flags & 0x18) >> 3
        will_flag = (flags & 0x04) == 0x04
        clean_session = (flags & 0x02) == 0x02
        reserved = flags & 0x01

        keepalive = self._decode_uint16(keepalive_colour)
        clientid, clientid_len = self._decode_string(clientid_colour)
        if will_flag:
            will_topic, will_topic_len = self._decode_string(WILL_colour)
            will_message, will_message_len = self._decode_string(WILL_colour)
        if username_flag:
            username, username_len = self._decode_string(username_colour)
        else:
            username = None
        if password_flag:
            password, password_len = self._decode_string(password_colour)
        else:
            password = None

        self._output_text += f"Clean {cs_label}     {cleansession_colour}{clean_session}{ansi_reset}\n"
        self._output_text += f"Keepalive:         {keepalive_colour}{keepalive}{ansi_reset}\n"
        self._output_text += f"Client ID:         ({string_length_colour}length: {clientid_len}{ansi_reset}) {clientid_colour}{clientid}{ansi_reset}\n"
        if username is not None:
            self._output_text += f"Username:          ({string_length_colour}length: {username_len}{ansi_reset}) {username_colour}{username}{ansi_reset}\n"
        if password is not None:
            self._output_text += f"Password:          ({string_length_colour}length: {password_len}{ansi_reset}) {password_colour}{password}{ansi_reset}\n"
        if will_flag:
            self._output_text += "Will:\n"
            self._output_text += f"  Topic:           ({string_length_colour}{will_topic_len}{ansi_reset}) {topic_colour}{will_topic}{ansi_reset}\n"
            self._output_text += f"  QoS:             {qos_colour}{will_qos}{ansi_reset}\n"
            self._output_text += f"  Retain:          {retain_colour}{will_retain}{ansi_reset}\n"
            self._output_text += f"  Message:         ({string_length_colour}{will_message_len}{ansi_reset}) {payload_colour}{will_message}{ansi_reset}\n"
        if reserved:
            self._output_text += f"Malformed connect flags: {ansi_error}{reserved}{ansi_reset}\n"

        self._decode_excess_bytes()


    def _decode_connect_v3(self, proto_name, rl_start):
        self._output_text += f"Command:           {COMMAND_colour}CONNECT v3.1/v3.0{ansi_reset}\n"
        self._print_fixed_header(0x00)
        self._print_length(rl_start)
        if proto_name != "MQIsdp":
            self._output_text += f"Protocol name:     {ansi_error}{proto_name}{ansi_reset}\n"
        self._decode_connect_v34("start:  ")


    def _decode_connect_v4(self, proto_name, rl_start):
        self._output_text += f"Command:           {COMMAND_colour}CONNECT v3.1.1{ansi_reset}\n"
        self._print_fixed_header(0x00)
        self._print_length(rl_start)
        if proto_name != "MQTT":
            self._output_text += f"Protocol name:     {ansi_error}{proto_name}{ansi_reset}\n"
        self._decode_connect_v34("session:")


    def _decode_connect_v5(self, proto_name, rl_start):
        self._output_text += f"Command:           {COMMAND_colour}CONNECT v5.0{ansi_reset}\n"
        self._print_fixed_header(0x00)
        self._print_length(rl_start)
        if proto_name != "MQTT":
            self._output_text += f"Protocol name:     {ansi_error}{proto_name}{ansi_reset}\n"

        flags = self._decode_byte(cleansession_colour)
        username_flag = flags & 0x80
        password_flag = flags & 0x40
        will_retain = (flags & 0x20) == 0x20
        will_qos = (flags & 0x18) >> 3
        will_flag = flags & 0x04
        clean_start = (flags & 0x02) == 0x02
        reserved = flags & 0x01

        keepalive = self._decode_uint16(keepalive_colour)
        clientid, clientid_len = self._decode_string(clientid_colour)
        if will_flag:
            will_topic, will_topic_len = self._decode_string(WILL_colour)
            will_message, will_message_len = self._decode_string(WILL_colour)
        if username_flag:
            username, username_len = self._decode_string(username_colour)
        else:
            username = None
        if password_flag:
            password, password_len = self._decode_string(password_colour)
        else:
            password = None

        self._output_text += f"Clean start:       {cleansession_colour}{clean_start}{ansi_reset}\n"
        self._output_text += f"Keepalive:         {keepalive_colour}{keepalive}{ansi_reset}\n"
        self._output_text += f"Client ID:         ({string_length_colour}length: {clientid_len}{ansi_reset}) {clientid_colour}{clientid}{ansi_reset}\n"
        if username is not None:
            self._output_text += f"Username:          ({string_length_colour}length: {username_len}{ansi_reset}) {username_colour}{username}{ansi_reset}\n"
        if password is not None:
            self._output_text += f"Password:          ({string_length_colour}length: {password_len}{ansi_reset}) {password_colour}{password}{ansi_reset}\n"
        if will_flag:
            self._output_text += "Will:\n"
            self._output_text += f"  Topic:           ({string_length_colour}{will_topic_len}{ansi_reset}) {topic_colour}{will_topic}{ansi_reset}\n"
            self._output_text += f"  QoS:             {qos_colour}{will_qos}{ansi_reset}\n"
            self._output_text += f"  Retain:          {retain_colour}{will_retain}{ansi_reset}\n"
            self._output_text += f"  Message:         ({string_length_colour}{will_message_len}{ansi_reset}) {payload_colour}{will_message}{ansi_reset}\n"
        if reserved:
            self._output_text += f"Malformed connect flags: {ansi_error}{reserved}{ansi_reset}\n"

        self._decode_properties()
        self._decode_excess_bytes()



    def _decode_connect_unknown(self, proto_name, proto_ver, rl_start):
        self._output_text += f"Command:           {COMMAND_colour}CONNECT {ansi_error}unknown{ansi_reset}\n"
        self._print_fixed_header(0x00)
        self._print_length(rl_start)
        self._output_text += f"Protocol name:     {proto_name}\n"
        self._output_text += f"Protocol version:  {proto_ver}\n"
        self._decode_excess_bytes()


    def _decode_connect(self):
        self._output_hex = f"{COMMAND_colour}{self._hdr:02x}{ansi_reset} " + self._output_hex
        rl_start = self._rl
        proto_name, _ = self._decode_string(ansi_br_yellow)
        proto_ver = self._decode_byte(ansi_br_yellow)

        if proto_ver == 5:
            self._decode_connect_v5(proto_name, rl_start)
        elif proto_ver == 4:
            self._decode_connect_v4(proto_name, rl_start)
        elif proto_ver == 3:
            self._decode_connect_v3(proto_name, rl_start)
        else:
            self._decode_connect_unknown(proto_name, proto_ver, rl_start)
        self._get_output_v4()


    def _decode_connack_v4(self):
        self._output_text += f"Command:           {COMMAND_colour}CONNACK v3.1.1{ansi_reset}\n"
        self._output_hex = f"{COMMAND_colour}{self._hdr:02x}{ansi_reset} " + self._output_hex
        self._print_fixed_header(0x00)
        self._print_length(self._rl)

        resv = self._decode_byte(cleansession_colour)
        if isinstance(resv, int):
            self._output_text += f"Session present:   {(resv & 0x01) == 0x01}\n"
            if resv & 0xFE:
                self._output_text += f"Malformed connect acknowledge: {ansi_error}{resv}{ansi_reset}\n"
        else:
            self._output_text += f"Connect acknowledge: {resv}\n"

        rc = self._decode_byte(rc_colour)
        try:
            rc_str = connack_strings[rc]
        except KeyError:
            rc_str = f"{ansi_error}Invalid return code{ansi_reset}"
        self._output_text += f"Return code:       {rc_colour}{rc} ({rc_str}){ansi_reset}\n"
        self._decode_excess_bytes()
        self._get_output_v4()


    def _decode_connack_v5(self):
        self._output_text += f"Command:           {COMMAND_colour}CONNACK v5.0{ansi_reset}\n"
        self._output_hex = f"{COMMAND_colour}{self._hdr:02x}{ansi_reset} " + self._output_hex
        self._print_fixed_header(0x00)
        self._print_length(self._rl)

        resv = self._decode_byte(cleansession_colour)
        if isinstance(resv, int):
            self._output_text += f"Session present:   {(resv & 0x01) == 0x01}\n"
            if resv & 0xFE:
                self._output_text += f"Malformed connect acknowledge: {ansi_error}{resv}{ansi_reset}\n"
        else:
            self._output_text += f"Connect acknowledge: {resv}\n"

        rc = self._decode_byte(rc_colour)
        try:
            rc_str = reason_code_strings[rc]
        except KeyError:
            rc_str = f"{ansi_error}Invalid reason code{ansi_reset}"
        self._output_text += f"Reason code:       {rc_colour}{rc} ({rc_str}){ansi_reset}\n"
        self._decode_properties()
        self._decode_excess_bytes()
        self._get_output_v5()


    def _decode_connack(self):
        if self.args.force_version is None or self.args.force_version == 4:
            self._decode_connack_v4()

        if self.args.force_version is None or self.args.force_version == 5:
            self._restore_state()
            self._decode_connack_v5()


    def _decode_payload(self):
        if self._rl <= 0 or self._packet is None:
            self._output_text += "Payload:\n"

        payload = struct.unpack(f"{self._rl}s", self._packet[0:self._rl])[0]
        self._packet = self._packet[self._rl:]
        plen = self._rl
        self._rl = 0
        try:
            p = payload.decode('utf-8')
        except UnicodeDecodeError:
            p = payload.hex()
        self._output_text += f"Payload:           ({string_length_colour}length: {plen}{ansi_reset}) {payload_colour}{p}{ansi_reset}\n"


    def _decode_publish_v4(self):
        if self._hdr & 0x01:
            retain = "retain"
        else:
            retain = "no-retain"
        qos = (self._hdr & 0x06) >> 1
        if self._hdr & 0x08:
            dup = "dup"
        else:
            dup = ""

        if qos == 3:
            qos = f"{ansi_error}3{ansi_reset}"

        self._output_text += f"Command:           {COMMAND_colour}PUBLISH v3.1.1{ansi_reset}\n"
        self._output_hex = f"{COMMAND_colour}{self._hdr:02x}{ansi_reset} " + self._output_hex
        self._print_length(self._rl)

        topic, topic_len = self._decode_string(topic_colour)

        self._output_text += f"Topic:             ({string_length_colour}length: {topic_len}{ansi_reset}) {topic_colour}{topic}{ansi_reset}\n"
        self._output_text += f"QoS:               {qos_colour}{qos}{ansi_reset}\n"
        self._output_text += f"Flags:             {retain_colour}{retain}{ansi_reset} {dup_colour}{dup}{ansi_reset}\n"
        if qos == 1 or qos == 2:
            self._decode_mid()

        self._decode_payload()
        self._get_output_v4()


    def _decode_publish_v5(self):
        if self._hdr & 0x01:
            retain = "retain"
        else:
            retain = "no-retain"
        qos = (self._hdr & 0x06) >> 1
        if self._hdr & 0x08:
            dup = "dup"
        else:
            dup = ""

        if qos == 3:
            qos = f"{ansi_error}3{ansi_reset}"

        self._output_text += f"Command:           {COMMAND_colour}PUBLISH v5.0{ansi_reset}\n"
        self._output_hex = f"{COMMAND_colour}{self._hdr:02x}{ansi_reset} " + self._output_hex
        self._print_length(self._rl)

        topic, topic_len = self._decode_string(topic_colour)

        self._output_text += f"Topic:             ({string_length_colour}length: {topic_len}{ansi_reset}) {topic_colour}{topic}{ansi_reset}\n"
        self._output_text += f"QoS:               {qos_colour}{qos}{ansi_reset}\n"
        self._output_text += f"Flags:             {retain_colour}{retain}{ansi_reset} {dup_colour}{dup}{ansi_reset}\n"
        if qos == 1 or qos == 2:
            self._decode_mid()
        self._decode_properties()
        self._decode_payload()
        self._get_output_v5()


    def _decode_publish(self):
        if self.args.force_version is None or self.args.force_version == 4:
            self._decode_publish_v4()

        if self.args.force_version is None or self.args.force_version == 5:
            self._restore_state()
            self._decode_publish_v5()


    def _decode_pubflow_v5(self):
        self._print_length(self._rl)
        self._decode_mid()
        if self._packet is not None and len(self._packet) > 0:
            self._decode_reason_code()
        else:
            self._print_reason_code(0) # implied success by omission
        self._decode_properties()
        self._decode_excess_bytes()
        self._get_output_v5()


    def _decode_pubflow_v4(self):
        self._print_length(self._rl)
        self._decode_mid()
        self._decode_excess_bytes()
        self._get_output_v4()


    def _decode_puback(self):
        if self.args.force_version is None or self.args.force_version == 4:
            self._output_hex = f"{COMMAND_colour}{self._hdr:02x}{ansi_reset} " + self._output_hex
            self._output_text += f"Command:           {COMMAND_colour}PUBACK v3.1.1{ansi_reset}\n"
            self._print_fixed_header(0x00)
            self._decode_pubflow_v4()

        if self.args.force_version is None or self.args.force_version == 5:
            self._restore_state()
            self._output_hex = f"{COMMAND_colour}{self._hdr:02x}{ansi_reset} " + self._output_hex
            self._output_text += f"Command:           {COMMAND_colour}PUBACK v5.0{ansi_reset}\n"
            self._print_fixed_header(0x00)
            self._decode_pubflow_v5()


    def _decode_pubrec(self):
        if self.args.force_version is None or self.args.force_version == 4:
            self._output_hex = f"{COMMAND_colour}{self._hdr:02x}{ansi_reset} " + self._output_hex
            self._output_text += f"Command:           {COMMAND_colour}PUBREC v3.1.1{ansi_reset}\n"
            self._print_fixed_header(0x00)
            self._decode_pubflow_v4()

        if self.args.force_version is None or self.args.force_version == 5:
            self._restore_state()
            self._output_hex = f"{COMMAND_colour}{self._hdr:02x}{ansi_reset} " + self._output_hex
            self._output_text += f"Command:           {COMMAND_colour}PUBREC v5.0{ansi_reset}\n"
            self._print_fixed_header(0x00)
            self._decode_pubflow_v5()


    def _decode_pubrel(self):
        if self.args.force_version is None or self.args.force_version == 4:
            self._output_hex = f"{COMMAND_colour}{self._hdr:02x}{ansi_reset} " + self._output_hex
            self._output_text += f"Command:           {COMMAND_colour}PUBREL v3.1.1{ansi_reset}\n"
            self._print_fixed_header(0x00)
            self._decode_pubflow_v4()

        if self.args.force_version is None or self.args.force_version == 5:
            self._restore_state()
            self._output_hex = f"{COMMAND_colour}{self._hdr:02x}{ansi_reset} " + self._output_hex
            self._output_text += f"Command:           {COMMAND_colour}PUBREL v5.0{ansi_reset}\n"
            self._print_fixed_header(0x00)
            self._decode_pubflow_v5()


    def _decode_pubcomp(self):
        if self.args.force_version is None or self.args.force_version == 4:
            self._output_hex = f"{COMMAND_colour}{self._hdr:02x}{ansi_reset} " + self._output_hex
            self._output_text += f"Command:           {COMMAND_colour}PUBCOMP v3.1.1{ansi_reset}\n"
            self._print_fixed_header(0x00)
            self._decode_pubflow_v4()

        if self.args.force_version is None or self.args.force_version == 5:
            self._restore_state()
            self._output_hex = f"{COMMAND_colour}{self._hdr:02x}{ansi_reset} " + self._output_hex
            self._output_text += f"Command:           {COMMAND_colour}PUBCOMP v5.0{ansi_reset}\n"
            self._print_fixed_header(0x00)
            self._decode_pubflow_v5()


    def _decode_subscribe_v4(self):
        self._output_text += f"Command:           {COMMAND_colour}SUBSCRIBE v3.1.1{ansi_reset}\n"
        self._output_hex = f"{COMMAND_colour}{self._hdr:02x}{ansi_reset} " + self._output_hex
        self._print_fixed_header(0x02)
        self._print_length(self._rl)
        self._decode_mid()
        while self._rl > 0:
            topic, topic_len = self._decode_string(topic_colour)
            qos = self._decode_byte(qos_colour)
            if isinstance(qos, int) and qos > 2:
                qos = f"{ansi_error}3{ansi_reset}"
            self._output_text += f"Topic:             ({string_length_colour}length: {topic_len}{ansi_reset}) {topic_colour}{topic}{ansi_reset}\n"
            self._output_text += f"  QoS:             {qos_colour}{qos}{ansi_reset}\n"

        self._decode_excess_bytes()
        self._get_output_v4()


    def _decode_subscribe_v5(self):
        self._output_text += f"Command:           {COMMAND_colour}SUBSCRIBE v5.0{ansi_reset}\n"
        self._output_hex = f"{COMMAND_colour}{self._hdr:02x}{ansi_reset} " + self._output_hex
        self._print_fixed_header(0x02)
        self._print_length(self._rl)
        self._decode_mid()
        self._decode_properties()
        while self._rl > 0:
            topic, topic_len = self._decode_string(topic_colour)
            options = self._decode_byte(sub_opt_colour)
            if isinstance(options, int):
                qos = options & 0x03
                if qos == 3:
                    qos = f"{ansi_error}3{ansi_reset}"
                self._output_text += f"Topic:             ({string_length_colour}length: {topic_len}{ansi_reset}) {topic_colour}{topic}{ansi_reset}\n"
                self._output_text += f"  QoS:             {qos_colour}{qos}{ansi_reset}\n"
                if options & 0x04:
                    self._output_text += f"  Flags:           {sub_opt_colour}no-local{ansi_reset}\n"
                if options & 0x08:
                    self._output_text += f"  Flags:           {sub_opt_colour}retain-as-published{ansi_reset}\n"
                retain_handling = options & 0x30
                if retain_handling == 0x00:
                    self._output_text += f"  Flags:           {sub_opt_colour}send-retain-on-subscription{ansi_reset}\n"
                elif retain_handling == 0x10:
                    self._output_text += f"  Flags:           {sub_opt_colour}send-retain-on-new-subscription{ansi_reset}\n"
                elif retain_handling == 0x20:
                    self._output_text += f"  Flags:           {sub_opt_colour}send-retain-never{ansi_reset}\n"
                else:
                    self._output_text += f"  Flags:           {ansi_error}send-retain-malformed{ansi_reset}\n"
                if options & 0xC0:
                    self._output_text += f"  Flags:           {ansi_error}Subscription options malformed: {options:02x}{ansi_reset}\n"
            else:
                self._output_text += f"Topic:             ({string_length_colour}length: {topic_len}{ansi_reset}) {topic_colour}{topic}{ansi_reset}\n"
                self._output_text += f"  Flags:           {ansi_error}Subscription options malformed: {options}{ansi_reset}\n"

        self._decode_excess_bytes()
        self._get_output_v5()


    def _decode_subscribe(self):
        if self.args.force_version is None or self.args.force_version == 4:
            self._decode_subscribe_v4()

        if self.args.force_version is None or self.args.force_version == 5:
            self._restore_state()
            self._decode_subscribe_v5()


    def _decode_suback_v4(self):
        self._output_text += f"Command:           {COMMAND_colour}SUBACK v3.1.1{ansi_reset}\n"
        self._output_hex = f"{COMMAND_colour}{self._hdr:02x}{ansi_reset} " + self._output_hex
        self._print_fixed_header(0x00)
        self._print_length(self._rl)
        self._decode_mid()
        if self._packet is None or len(self._packet) == 0:
            self._output_text += f"Granted Qos:       {errstr}\n"
        while self._rl > 0:
            qos = self._decode_byte(qos_colour)
            if isinstance(qos, int) and qos <= 2:
                self._output_text += f"Granted QoS:       {qos_colour}{qos}{ansi_reset}\n"
            else:
                self._output_text += f"Granted QoS:       {ansi_error}{qos}{ansi_reset}\n"
        self._get_output_v4()


    def _decode_suback_v5(self):
        self._output_text += f"Command:           {COMMAND_colour}SUBACK v5.0{ansi_reset}\n"
        self._output_hex = f"{COMMAND_colour}{self._hdr:02x}{ansi_reset} " + self._output_hex
        self._print_fixed_header(0x00)
        self._print_length(self._rl)
        self._decode_mid()
        self._decode_properties()
        if self._packet is None or len(self._packet) == 0:
            self._output_text += f"Reason code:       {errstr}\n"
        while self._rl > 0:
            byte = self._decode_byte(rc_colour)
            if isinstance(byte, int) and byte <= 2:
                self._output_text += f"Reason code:       {byte}\n"
            else:
                self._print_reason_code(byte)
        self._get_output_v5()


    def _decode_suback(self):
        if self.args.force_version is None or self.args.force_version == 4:
            self._decode_suback_v4()

        if self.args.force_version is None or self.args.force_version == 5:
            self._restore_state()
            self._decode_suback_v5()


    def _decode_unsubscribe_v4(self):
        self._output_text += f"Command:           {COMMAND_colour}UNSUBSCRIBE v3.1.1{ansi_reset}\n"
        self._output_hex = f"{COMMAND_colour}{self._hdr:02x}{ansi_reset} " + self._output_hex
        self._print_fixed_header(0x02)
        self._print_length(self._rl)
        self._decode_mid()
        while self._rl > 0:
            topic, topic_len = self._decode_string(topic_colour)
            self._output_text += f"Topic:             ({string_length_colour}length: {topic_len}{ansi_reset}) {topic_colour}{topic}{ansi_reset}\n"

        self._decode_excess_bytes()
        self._get_output_v4()


    def _decode_unsubscribe_v5(self):
        self._output_text += f"Command:           {COMMAND_colour}UNSUBSCRIBE v5.0{ansi_reset}\n"
        self._output_hex = f"{COMMAND_colour}{self._hdr:02x}{ansi_reset} " + self._output_hex
        self._print_fixed_header(0x02)
        self._print_length(self._rl)
        self._decode_mid()
        self._decode_properties()
        while self._rl > 0:
            topic, topic_len = self._decode_string(topic_colour)
            self._output_text += f"Topic:             ({string_length_colour}length: {topic_len}{ansi_reset}) {topic_colour}{topic}{ansi_reset}\n"

        self._decode_excess_bytes()
        self._get_output_v5()


    def _decode_unsubscribe(self):
        if self.args.force_version is None or self.args.force_version == 4:
            self._decode_unsubscribe_v4()

        if self.args.force_version is None or self.args.force_version == 5:
            self._restore_state()
            self._decode_unsubscribe_v5()


    def _decode_unsuback_v4(self):
        self._output_text += f"Command:           {COMMAND_colour}UNSUBACK v3.1.1{ansi_reset}\n"
        self._output_hex = f"{COMMAND_colour}{self._hdr:02x}{ansi_reset} " + self._output_hex
        self._print_fixed_header(0x00)
        self._print_length(self._rl)
        self._decode_mid()
        self._decode_excess_bytes()
        self._get_output_v4()


    def _decode_unsuback_v5(self):
        self._output_text += f"Command:           {COMMAND_colour}UNSUBACK v5.0{ansi_reset}\n"
        self._output_hex = f"{COMMAND_colour}{self._hdr:02x}{ansi_reset} " + self._output_hex
        self._print_fixed_header(0x00)
        self._print_length(self._rl)
        self._decode_mid()
        self._decode_properties()
        while self._rl > 0:
            self._decode_reason_code()
        self._get_output_v5()


    def _decode_unsuback(self):
        if self.args.force_version is None or self.args.force_version == 4:
            self._decode_unsuback_v4()

        if self.args.force_version is None or self.args.force_version == 5:
            self._restore_state()
            self._decode_unsuback_v5()


    def _decode_ping(self, label):
        self._output_text += f"Command:           {COMMAND_colour}{label} v3.1.1/v5.0{ansi_reset}\n"
        self._output_hex = f"{COMMAND_colour}{self._hdr:02x}{ansi_reset} " + self._output_hex
        self._print_fixed_header(0x00)
        self._print_length(self._rl, 0)
        self._decode_excess_bytes()
        self._get_output_v4()


    def _decode_pingreq(self):
        self._decode_ping("PINGREQ")


    def _decode_pingresp(self):
        self._decode_ping("PINGRESP")


    def _decode_disconnect_v4(self):
        self._output_text += f"Command:           {COMMAND_colour}DISCONNECT v3.1.1{ansi_reset}\n"
        self._output_hex = f"{COMMAND_colour}{self._hdr:02x}{ansi_reset} " + self._output_hex
        self._print_fixed_header(0x00)
        self._print_length(self._rl, 0)
        self._decode_excess_bytes()
        self._get_output_v4()


    def _decode_disconnect_v5(self):
        self._output_text += f"Command:           {COMMAND_colour}DISCONNECT v5.0{ansi_reset}\n"
        self._output_hex = f"{COMMAND_colour}{self._hdr:02x}{ansi_reset} " + self._output_hex
        self._print_fixed_header(0x00)
        self._print_length(self._rl)
        self._decode_reason_code()
        self._decode_properties()
        self._decode_excess_bytes()
        self._get_output_v5()


    def _decode_disconnect(self):
        if self.args.force_version is None or self.args.force_version == 4:
            self._decode_disconnect_v4()

        if self.args.force_version is None or self.args.force_version == 5:
            self._restore_state()
            self._decode_disconnect_v5()


    def _decode_auth_v4(self):
        self._output_text += f"Command:           {ansi_error}AUTH{ansi_reset}\n"
        self._output_hex = f"{COMMAND_colour}{self._hdr:02x}{ansi_reset} " + self._output_hex
        self._print_length(self._rl)
        self._decode_excess_bytes()
        self._get_output_v4()

    def _decode_auth_v5(self):
        self._output_text += f"Command:           {COMMAND_colour}AUTH v5.0{ansi_reset}\n"
        self._output_hex = f"{COMMAND_colour}{self._hdr:02x}{ansi_reset} " + self._output_hex
        self._print_fixed_header(0x00)
        self._print_length(self._rl)
        self._decode_reason_code()
        self._decode_properties()
        self._decode_excess_bytes()
        self._get_output_v5()

    def _decode_auth(self):
        if self.args.force_version is None or self.args.force_version == 4:
            self._decode_auth_v4()

        if self.args.force_version is None or self.args.force_version == 5:
            self._restore_state()
            self._decode_auth_v5()


    def _decode_packet(self):
        self._output_text = ""
        self._output_text_v4 = ""
        self._output_text_v5 = ""
        self._output_hex = ""
        self._output_hex_v4 = ""
        self._output_hex_v5 = ""
        self._hdr, self._packet = struct.unpack("!B%ds" % (len(self._packet)-1), bytes(self._packet))
        self._rl = 100 # to keep decode_varint happy
        self._rl, _ = self._decode_varint(length_colour)
        self._save_state()

        cmd = self._hdr & 0xF0
        if cmd == 0x00:
            self._decode_reserved()
        elif cmd == 0x10:
            self._decode_connect()
        elif cmd == 0x20:
            self._decode_connack()
        elif cmd == 0x30:
            self._decode_publish()
        elif cmd == 0x40:
            self._decode_puback()
        elif cmd == 0x50:
            self._decode_pubrec()
        elif cmd == 0x60:
            self._decode_pubrel()
        elif cmd == 0x70:
            self._decode_pubcomp()
        elif cmd == 0x80:
            self._decode_subscribe()
        elif cmd == 0x90:
            self._decode_suback()
        elif cmd == 0xA0:
            self._decode_unsubscribe()
        elif cmd == 0xB0:
            self._decode_unsuback()
        elif cmd == 0xC0:
            self._decode_pingreq()
        elif cmd == 0xD0:
            self._decode_pingresp()
        elif cmd == 0xE0:
            self._decode_disconnect()
        elif cmd == 0xF0:
            self._decode_auth()
        return ""

def get_args():
    parser = argparse.ArgumentParser(
        prog="mqttdecoder",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description="Copyright (C) 2024 Roger Light\n\nDecode hex strings of MQTT packets into a human readable form",
        epilog="https://github.com/mqtt-tools/mqttdecode"
    )

    parser.add_argument(
        "--force-version", action="store", type=int, default=None,
        choices=[4, 5],
        help="force MQTT protocol version to use: 4 (for v3.1.1), or 5 (for v5.0). Does not apply to CONNECT packets"
    )

    parser.add_argument('--file', type=str, help='file to read strings from')
    parser.add_argument('hex', metavar='hex', type=str, nargs='*', help='a hex string to parse')

    return parser.parse_args()

def check_args(args):
    pass

def main():
    args = get_args()
    check_args(args)

    decoder = mqttdecode(args)

    if len(args.hex) > 0:
        decoder.decode("".join(args.hex))

main()

#!/usr/bin/env python3

# (C) 2024  Roger Light <roger@atchoo.org>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

import argparse
import struct
import sys

ansi_reset = "\u001b[0m"
ansi_error = "\u001b[31;7m"
ansi_red = "\u001b[31m"
ansi_green = "\u001b[32m"
ansi_yellow = "\u001b[33m"
ansi_blue = "\u001b[34m"
ansi_magenta = "\u001b[35m"
ansi_cyan = "\u001b[36m"
ansi_white = "\u001b[37m"
ansi_br_black = "\u001b[90m"
ansi_br_red = "\u001b[91m"
ansi_br_green = "\u001b[92m"
ansi_br_yellow = "\u001b[93m"
ansi_br_blue = "\u001b[94m"
ansi_br_magenta = "\u001b[95m"
ansi_br_cyan = "\u001b[96m"
ansi_br_white = "\u001b[97m"
ansi_br_yellow2 = "\u001b[38;5;228m"

connack_strings = {
    0: "accepted",
    1: "refused: protocol version",
    2: "refused: identifier rejected",
    3: "refused: server unavailable",
    4: "refused: bad username or password",
    5: "refused: not authorized",
}

reason_code_strings = {
    0: "success",
    4: "disconnect with will message",
    16: "no matching subscribers",
    17: "no subscription existed",
    24: "continue authentication",
    25: "reauthenticate",
    128: "unspecified",
    129: "malformed packet",
    130: "protocol error",
    131: "implementation specific",
    132: "unsupported protocol version",
    133: "clientid not valid",
    134: "bad username or password",
    135: "not authorized",
    136: "server unavailable",
    137: "server busy",
    138: "banned",
    139: "server shutting down",
    140: "bad authentication method",
    141: "keep alive timeout",
    142: "session taken over",
    143: "topic filter invalid",
    144: "topic name invalid",
    145: "packet id in use",
    146: "packet id not found",
    147: "receive maximum exceeded",
    148: "topic alias invalid",
    149: "packet too large",
    150: "message rate too high",
    151: "quota exceeded",
    152: "administrative action",
    153: "payload format invalid",
    154: "retain not supported",
    155: "qos not supported",
    156: "use another server",
    157: "server moved",
    158: "shared subscriptions not supported",
    159: "connection rate exceeded",
    160: "maximum connection time",
    161: "subscription identifiers not supported",
    162: "wildcard subscriptions not supported",
}

all_props = {
   0x01: ("payload-format-indicator", "byte"),
   0x02: ("message-expiry-interval", "uint32"),
   0x03: ("content-type", "string"),
   0x08: ("response-topic", "string"),
   0x09: ("correlation-data", "string"),
   0x0b: ("subscription-identifier", "varint"),
   0x11: ("session-expiry-interval", "uint32"),
   0x12: ("assigned-client-identifier", "string"),
   0x13: ("server-keep-alive", "uint16"),
   0x15: ("authentication-method", "string"),
   0x16: ("authentication-data", "string"),
   0x17: ("request-problem-information", "byte"),
   0x18: ("will-delay-interval", "uint32"),
   0x19: ("request-response-information", "byte"),
   0x1a: ("response-information", "string"),
   0x1c: ("server-reference", "string"),
   0x1f: ("reason-string", "string"),
   0x21: ("receive-maximum", "uint16"),
   0x22: ("topic-alias-maximum", "uint16"),
   0x23: ("topic-alias", "uint16"),
   0x24: ("maximum-qos", "byte"),
   0x25: ("retain-available", "byte"),
   0x26: ("user-property", "stringpair"),
   0x27: ("maximum-packet-size", "uint32"),
   0x28: ("wildcard-subscription-available", "byte"),
   0x29: ("subscription-identifier-available", "byte"),
   0x2a: ("shared-subscription-available", "byte"),
}

class COLOURS():
    def __init__(self, colourful):
        self._colourful = colourful
        self._colours = {
            'cleansession': ansi_br_cyan,
            'clientid': ansi_br_cyan,
            'command': ansi_yellow,
            'dup': ansi_br_cyan,
            'error': ansi_error,
            'keepalive': ansi_br_cyan,
            'length': ansi_br_magenta,
            'mid': ansi_br_cyan,
            'password': ansi_br_cyan,
            'payload': ansi_br_blue,
            'property': ansi_br_blue,
            'protover': ansi_br_cyan,
            'qos': ansi_br_cyan,
            'rc': ansi_br_cyan,
            'reset': ansi_reset,
            'retain': ansi_br_cyan,
            'strlen': ansi_br_yellow2,
            'subopt': ansi_br_cyan,
            'topic': ansi_br_yellow,
            'username': ansi_br_cyan,
            'will': ansi_br_blue,
        }

    def __getitem__(self, key):
        if self._colourful:
            return self._colours[key]
        else:
            return ""

class mqttdecode():
    def __init__(self, args):
        self.args = args
        self.cols = COLOURS(not args.no_colour)
        self.errstr = f"{self.cols['error']}?{self.cols['reset']}"

    def decode(self, hexstring):
        try:
            self._packet = bytes.fromhex(hexstring)
        except ValueError:
            print(f"Input is not valid hex: {hexstring}")
            return
        while self._packet is not None and len(self._packet) > 0:
            cur_packet = self._packet
            self._decode_packet()
            if self._packet is not None:
                cur_packet = cur_packet[0:len(cur_packet)-len(self._packet)]

            if len(self._output_hex_v4) > 0:
                print(f"Hex:               {self._output_hex_v4}")
                print(self._output_text_v4)

            if len(self._output_hex_v5) > 0:
                print(f"Hex:               {self._output_hex_v5}")
                print(self._output_text_v5)

            if self._packet is not None and len(self._packet) > 0:
                print("------------------------------\n")

    def _save_state(self):
        self._packet_save = self._packet
        self._rl_save = self._rl
        self._output_hex_save = self._output_hex

    def _restore_state(self):
        self._packet = self._packet_save
        self._rl = self._rl_save
        self._output_hex = self._output_hex_save

    def _decode_excess_bytes(self):
        if self._rl == 0:
            return
        if self._packet is not None and len(self._packet) > 0:
            self._output_text += f"Excess bytes:      {self.cols['error']}{self._packet[0:self._rl].hex()}{self.cols['reset']}\n"
            self._output_hex += f"{self.cols['error']}{self._packet[0:self._rl].hex()}{self.cols['reset']}"
            self._packet = self._packet[self._rl:]
        self._rl = 0


    def _get_output_v4(self):
        self._output_text_v4 = self._output_text
        self._output_hex_v4 = self._output_hex
        self._output_text = ""
        self._output_hex = ""

    def _get_output_v5(self):
        self._output_text_v5 = self._output_text
        self._output_hex_v5 = self._output_hex
        self._output_text = ""
        self._output_hex = ""

    def _decode_byte(self, col):
        if self._rl <= 0:
            return self.errstr
        try:
            byte = self._packet[0]
            self._output_hex += f"{col}{byte:02x}{self.cols['reset']} "
            self._packet = self._packet[1:]
        except (IndexError, TypeError):
            byte = self.errstr
            if len(self._packet) < 1:
                self._packet = None
        self._rl -= 1
        return byte


    def _decode_uint16(self, col):
        if self._rl <= 0:
            return self.errstr
        try:
            i16 = struct.unpack('!H', self._packet[0:2])[0]
            self._output_hex += f"{col}{self._packet[0:2].hex()}{self.cols['reset']} "
            self._packet = self._packet[2:]
        except (IndexError, struct.error, TypeError):
            i16 = self.errstr
            if len(self._packet) < 2:
                self._packet = None
        self._rl -= 2
        return i16


    def _decode_uint32(self, col):
        if self._rl <= 0:
            return self.errstr
        try:
            i32 = struct.unpack('!I', self._packet[0:4])[0]
            self._output_hex += f"{col}{self._packet[0:4].hex()}{self.cols['reset']} "
            self._packet = self._packet[4:]
        except (IndexError, struct.error):
            i32 = self.errstr
            if len(self._packet) < 4:
                self._packet = None
        self._rl -= 4
        return i32


    def _decode_varint(self, col):
        if self._rl <= 0:
            return self.errstr, 0
        mult = 1
        varint = 0
        vl = 0
        for i in range(0,4):
            if self._rl <= 0:
                return self.errstr, vl
            try:
                byte = self._packet[0]
                self._packet = self._packet[1:]
                self._output_hex += f"{col}{byte:02x}{self.cols['reset']} "
            except IndexError:
                varint = self.errstr
                return (varint, vl)
            self._rl -= 1

            vl += 1
            varint += (byte & 127) * mult
            mult *= 128
            if byte & 128 == 0:
                break

        return (varint, vl)


    def _decode_string(self, col):
        if isinstance(self._rl, str) or self._rl <= 0:
            return self.errstr, self.errstr
        slen_full = self._decode_uint16(self.cols['strlen'])
        if isinstance(slen_full, int):
            if slen_full == 0:
                return "", 0
            try:
                slen = min(slen_full, self._rl)
                s = struct.unpack(f'!{slen}s', self._packet[0:slen])[0]
                self._output_hex += f"{col}{self._packet[0:slen].hex()}{self.cols['reset']} "
                self._rl -= slen
                self._packet = self._packet[slen:]
                s = s.decode('utf-8')
                if slen < slen_full:
                    s += self.errstr
                return s, slen_full
            except (IndexError, struct.error, UnicodeDecodeError):
                return self.errstr, self.errstr
        else:
            return self.errstr, self.errstr


    def _decode_properties(self):
        if self._rl <= 0:
            return
        if self._packet is None or len(self._packet) == 0:
            return
        pl, _ = self._decode_varint(self.cols['property'])
        if pl > self._rl:
            self._output_text += f"Properties Length: {self.cols['error']}{pl} > remaining length{self.cols['reset']}\n"
            return
        else:
            self._output_text += f"Properties Length: {pl}\n"
        if not isinstance(pl, int):
            return

        while self._rl > 0 and pl > 0:
            prop, vl = self._decode_varint(self.cols['property'])
            pl -= vl

            try:
                propdef = all_props[prop]
            except KeyError:
                self._output_text += f"Property:          Unknown type: {self.cols['error']}{prop}{self.cols['reset']}\n"
                return 0, None
            self._output_text += f"Property:          {self.cols['property']}{prop},{propdef[0]} = "
            if propdef[1] == "byte":
                v = self._decode_byte(self.cols['property'])
                pl -= 1
            elif propdef[1] == "uint16":
                v = self._decode_uint16(self.cols['property'])
                pl -= 2
            elif propdef[1] == "uint32":
                v = self._decode_uint32(self.cols['property'])
                pl -= 4
            elif propdef[1] == "varint":
                v, vl = self._decode_varint(self.cols['property'])
                pl -= vl
            elif propdef[1] == "string":
                v, _ = self._decode_string(self.cols['property'])
                pl -= (len(v) + 2)
            elif propdef[1] == "stringpair":
                k, _ = self._decode_string(self.cols['property'])
                v, _ = self._decode_string(self.cols['property'])
                pl -= (len(k) + 2 + len(v) + 2)
                self._output_text += f"{k}:"
            self._output_text += f"{v}{self.cols['reset']}\n"


    def _decode_mid(self):
        mid = self._decode_uint16(self.cols['mid'])
        if isinstance(mid, int) and mid > 0:
            self._output_text += f"Packet ID:         {self.cols['mid']}{mid}{self.cols['reset']}\n"
        else:
            self._output_text += f"Packet ID:         {self.cols['error']}{mid}{self.cols['reset']}\n"


    def _print_fixed_header(self, expected):
        if self._hdr & 0x0F != expected:
            self._output_text += f"Fixed header:      {self.cols['error']}0x{self._hdr:02x}{self.cols['reset']}\n"


    def _print_length(self, rl, expected=-1):
        if isinstance(rl, str):
            self._output_text += f"Length:            {self.cols['length']}{rl}{self.cols['reset']}\n"
            exit(1)

        if expected == -1 or rl == expected:
            self._output_text += f"Length:            {self.cols['length']}{rl}{self.cols['reset']}\n"
        else:
            self._output_text += f"Length:            {self.cols['error']}{rl}{self.cols['reset']}\n"


    def _print_reason_code(self, rc):
        try:
            rc_str = reason_code_strings[rc]
        except KeyError:
            rc_str = f"{self.cols['error']}Invalid reason code{self.cols['reset']}"
        self._output_text += f"Reason code:       {self.cols['rc']}{rc} ({rc_str}){self.cols['reset']}\n"


    def _decode_reason_code(self):
        rc = self._decode_byte(self.cols['rc'])
        self._print_reason_code(rc)


    def _decode_reserved(self):
        self._output_text += f"Command:           {self.cols['error']}RESERVED{self.cols['reset']}\n"
        self._output_hex = f"{self.cols['error']}{self._hdr:02x}{self.cols['reset']} " + self._output_hex
        self._print_length(self._rl)
        self._decode_excess_bytes()
        self._get_output_v4()


    def _decode_connect_v34(self, cs_label):
        flags = self._decode_byte(self.cols['cleansession'])
        if isinstance(flags, str):
            return
        username_flag = (flags & 0x80) == 0x80
        password_flag = (flags & 0x40) == 0x40
        will_retain = (flags & 0x20) == 0x20
        will_qos = (flags & 0x18) >> 3
        will_flag = (flags & 0x04) == 0x04
        clean_session = (flags & 0x02) == 0x02
        reserved = flags & 0x01

        keepalive = self._decode_uint16(self.cols['keepalive'])
        clientid, clientid_len = self._decode_string(self.cols['clientid'])
        if will_flag:
            will_topic, will_topic_len = self._decode_string(self.cols['will'])
            will_message, will_message_len = self._decode_string(self.cols['will'])
        if username_flag:
            username, username_len = self._decode_string(self.cols['username'])
        else:
            username = None
        if password_flag:
            password, password_len = self._decode_string(self.cols['password'])
        else:
            password = None

        self._output_text += f"Clean {cs_label}     {self.cols['cleansession']}{clean_session}{self.cols['reset']}\n"
        self._output_text += f"Keepalive:         {self.cols['keepalive']}{keepalive}{self.cols['reset']}\n"
        self._output_text += f"Client ID:         ({self.cols['strlen']}length: {clientid_len}{self.cols['reset']}) {self.cols['clientid']}{clientid}{self.cols['reset']}\n"
        if username is not None:
            self._output_text += f"Username:          ({self.cols['strlen']}length: {username_len}{self.cols['reset']}) {self.cols['username']}{username}{self.cols['reset']}\n"
        if password is not None:
            self._output_text += f"Password:          ({self.cols['strlen']}length: {password_len}{self.cols['reset']}) {self.cols['password']}{password}{self.cols['reset']}\n"
        if will_flag:
            self._output_text += "Will:\n"
            self._output_text += f"  Topic:           ({self.cols['strlen']}{will_topic_len}{self.cols['reset']}) {self.cols['topic']}{will_topic}{self.cols['reset']}\n"
            self._output_text += f"  QoS:             {self.cols['qos']}{will_qos}{self.cols['reset']}\n"
            self._output_text += f"  Retain:          {self.cols['retain']}{will_retain}{self.cols['reset']}\n"
            self._output_text += f"  Message:         ({self.cols['strlen']}{will_message_len}{self.cols['reset']}) {self.cols['payload']}{will_message}{self.cols['reset']}\n"
        if reserved:
            self._output_text += f"Malformed connect flags: {self.cols['error']}{reserved}{self.cols['reset']}\n"

        self._decode_excess_bytes()


    def _decode_connect_v3(self, proto_name, rl_start):
        self._output_text += f"Command:           {self.cols['command']}CONNECT v3.1/v3.0{self.cols['reset']}\n"
        self._print_fixed_header(0x00)
        self._print_length(rl_start)
        if proto_name != "MQIsdp":
            self._output_text += f"Protocol name:     {self.cols['error']}{proto_name}{self.cols['reset']}\n"
        self._decode_connect_v34("start:  ")


    def _decode_connect_v4(self, proto_name, rl_start):
        self._output_text += f"Command:           {self.cols['command']}CONNECT v3.1.1{self.cols['reset']}\n"
        self._print_fixed_header(0x00)
        self._print_length(rl_start)
        if proto_name != "MQTT":
            self._output_text += f"Protocol name:     {self.cols['error']}{proto_name}{self.cols['reset']}\n"
        self._decode_connect_v34("session:")


    def _decode_connect_v5(self, proto_name, rl_start):
        self._output_text += f"Command:           {self.cols['command']}CONNECT v5.0{self.cols['reset']}\n"
        self._print_fixed_header(0x00)
        self._print_length(rl_start)
        if proto_name != "MQTT":
            self._output_text += f"Protocol name:     {self.cols['error']}{proto_name}{self.cols['reset']}\n"

        flags = self._decode_byte(self.cols['cleansession'])
        username_flag = flags & 0x80
        password_flag = flags & 0x40
        will_retain = (flags & 0x20) == 0x20
        will_qos = (flags & 0x18) >> 3
        will_flag = flags & 0x04
        clean_start = (flags & 0x02) == 0x02
        reserved = flags & 0x01

        keepalive = self._decode_uint16(self.cols['keepalive'])
        clientid, clientid_len = self._decode_string(self.cols['clientid'])
        if will_flag:
            will_topic, will_topic_len = self._decode_string(self.cols['will'])
            will_message, will_message_len = self._decode_string(self.cols['will'])
        if username_flag:
            username, username_len = self._decode_string(self.cols['username'])
        else:
            username = None
        if password_flag:
            password, password_len = self._decode_string(self.cols['password'])
        else:
            password = None

        self._output_text += f"Clean start:       {self.cols['cleansession']}{clean_start}{self.cols['reset']}\n"
        self._output_text += f"Keepalive:         {self.cols['keepalive']}{keepalive}{self.cols['reset']}\n"
        self._output_text += f"Client ID:         ({self.cols['strlen']}length: {clientid_len}{self.cols['reset']}) {self.cols['clientid']}{clientid}{self.cols['reset']}\n"
        if username is not None:
            self._output_text += f"Username:          ({self.cols['strlen']}length: {username_len}{self.cols['reset']}) {self.cols['username']}{username}{self.cols['reset']}\n"
        if password is not None:
            self._output_text += f"Password:          ({self.cols['strlen']}length: {password_len}{self.cols['reset']}) {self.cols['password']}{password}{self.cols['reset']}\n"
        if will_flag:
            self._output_text += "Will:\n"
            self._output_text += f"  Topic:           ({self.cols['strlen']}{will_topic_len}{self.cols['reset']}) {self.cols['topic']}{will_topic}{self.cols['reset']}\n"
            self._output_text += f"  QoS:             {self.cols['qos']}{will_qos}{self.cols['reset']}\n"
            self._output_text += f"  Retain:          {self.cols['retain']}{will_retain}{self.cols['reset']}\n"
            self._output_text += f"  Message:         ({self.cols['strlen']}{will_message_len}{self.cols['reset']}) {self.cols['payload']}{will_message}{self.cols['reset']}\n"
        if reserved:
            self._output_text += f"Malformed connect flags: {self.cols['error']}{reserved}{self.cols['reset']}\n"

        self._decode_properties()
        self._decode_excess_bytes()



    def _decode_connect_unknown(self, proto_name, proto_ver, rl_start):
        self._output_text += f"Command:           {self.cols['command']}CONNECT {self.cols['error']}unknown{self.cols['reset']}\n"
        self._print_fixed_header(0x00)
        self._print_length(rl_start)
        self._output_text += f"Protocol name:     {proto_name}\n"
        self._output_text += f"Protocol version:  {proto_ver}\n"
        self._decode_excess_bytes()


    def _decode_connect(self):
        self._output_hex = f"{self.cols['command']}{self._hdr:02x}{self.cols['reset']} " + self._output_hex
        rl_start = self._rl
        proto_name, _ = self._decode_string(ansi_br_yellow)
        proto_ver = self._decode_byte(ansi_br_yellow)

        if proto_ver == 5:
            self._decode_connect_v5(proto_name, rl_start)
        elif proto_ver == 4:
            self._decode_connect_v4(proto_name, rl_start)
        elif proto_ver == 3:
            self._decode_connect_v3(proto_name, rl_start)
        else:
            self._decode_connect_unknown(proto_name, proto_ver, rl_start)
        self._get_output_v4()


    def _decode_connack_v4(self):
        self._output_text += f"Command:           {self.cols['command']}CONNACK v3.1.1{self.cols['reset']}\n"
        self._output_hex = f"{self.cols['command']}{self._hdr:02x}{self.cols['reset']} " + self._output_hex
        self._print_fixed_header(0x00)
        self._print_length(self._rl)

        resv = self._decode_byte(self.cols['cleansession'])
        if isinstance(resv, int):
            self._output_text += f"Session present:   {(resv & 0x01) == 0x01}\n"
            if resv & 0xFE:
                self._output_text += f"Malformed connect acknowledge: {self.cols['error']}{resv}{self.cols['reset']}\n"
        else:
            self._output_text += f"Connect acknowledge: {resv}\n"

        rc = self._decode_byte(self.cols['rc'])
        try:
            rc_str = connack_strings[rc]
        except KeyError:
            rc_str = f"{self.cols['error']}Invalid return code{self.cols['reset']}"
        self._output_text += f"Return code:       {self.cols['rc']}{rc} ({rc_str}){self.cols['reset']}\n"
        self._decode_excess_bytes()
        self._get_output_v4()


    def _decode_connack_v5(self):
        self._output_text += f"Command:           {self.cols['command']}CONNACK v5.0{self.cols['reset']}\n"
        self._output_hex = f"{self.cols['command']}{self._hdr:02x}{self.cols['reset']} " + self._output_hex
        self._print_fixed_header(0x00)
        self._print_length(self._rl)

        resv = self._decode_byte(self.cols['cleansession'])
        if isinstance(resv, int):
            self._output_text += f"Session present:   {(resv & 0x01) == 0x01}\n"
            if resv & 0xFE:
                self._output_text += f"Malformed connect acknowledge: {self.cols['error']}{resv}{self.cols['reset']}\n"
        else:
            self._output_text += f"Connect acknowledge: {resv}\n"

        rc = self._decode_byte(self.cols['rc'])
        try:
            rc_str = reason_code_strings[rc]
        except KeyError:
            rc_str = f"{self.cols['error']}Invalid reason code{self.cols['reset']}"
        self._output_text += f"Reason code:       {self.cols['rc']}{rc} ({rc_str}){self.cols['reset']}\n"
        self._decode_properties()
        self._decode_excess_bytes()
        self._get_output_v5()


    def _decode_connack(self):
        if self.args.force_spec is None or self.args.force_spec == 4:
            self._decode_connack_v4()

        if self.args.force_spec is None or self.args.force_spec == 5:
            self._restore_state()
            self._decode_connack_v5()


    def _decode_payload(self):
        if self._rl <= 0 or self._packet is None:
            self._output_text += "Payload:\n"
            return

        decodelen = min(len(self._packet), self._rl)
        payload = struct.unpack(f"{decodelen}s", self._packet[0:decodelen])[0]
        self._packet = self._packet[decodelen:]
        plen = self._rl
        self._rl = 0
        try:
            p = payload.decode('utf-8')
        except UnicodeDecodeError:
            p = payload.hex()
        if decodelen < plen:
            p += self.errstr
        self._output_text += f"Payload:           (length: {plen}) {self.cols['payload']}{p}{self.cols['reset']}\n"
        self._output_hex += f"{self.cols['payload']}{payload.hex()}{self.cols['reset']}"


    def _decode_publish_v4(self):
        if self._hdr & 0x01:
            retain = "retain"
        else:
            retain = "no-retain"
        qos = (self._hdr & 0x06) >> 1
        if self._hdr & 0x08:
            dup = "dup"
        else:
            dup = ""

        if qos == 3:
            qos = f"{self.cols['error']}3{self.cols['reset']}"

        self._output_text += f"Command:           {self.cols['command']}PUBLISH v3.1.1{self.cols['reset']}\n"
        cmd = (self._hdr & 0xF0) >> 4
        flags = (self._hdr & 0x0F)
        self._output_hex = f"{self.cols['command']}{cmd:x}{self.cols['qos']}{flags:x}{self.cols['reset']} " + self._output_hex
        self._output_text += f"QoS:               {self.cols['qos']}{qos}{self.cols['reset']}\n"
        self._output_text += f"Flags:             {self.cols['retain']}{retain}{self.cols['reset']} {self.cols['dup']}{dup}{self.cols['reset']}\n"
        self._print_length(self._rl)

        topic, topic_len = self._decode_string(self.cols['topic'])

        self._output_text += f"Topic:             ({self.cols['strlen']}length: {topic_len}{self.cols['reset']}) {self.cols['topic']}{topic}{self.cols['reset']}\n"
        if qos == 1 or qos == 2:
            self._decode_mid()

        self._decode_payload()
        self._get_output_v4()


    def _decode_publish_v5(self):
        if self._hdr & 0x01:
            retain = "retain"
        else:
            retain = "no-retain"
        qos = (self._hdr & 0x06) >> 1
        if self._hdr & 0x08:
            dup = "dup"
        else:
            dup = ""

        if qos == 3:
            qos = f"{self.cols['error']}3{self.cols['reset']}"

        self._output_text += f"Command:           {self.cols['command']}PUBLISH v5.0{self.cols['reset']}\n"
        cmd = (self._hdr & 0xF0) >> 8
        flags = (self._hdr & 0x0F)
        self._output_hex = f"{self.cols['command']}{cmd:x}{self.cols['qos']}{flags:x}{self.cols['reset']} " + self._output_hex
        self._output_text += f"QoS:               {self.cols['qos']}{qos}{self.cols['reset']}\n"
        self._output_text += f"Flags:             {self.cols['retain']}{retain}{self.cols['reset']} {self.cols['dup']}{dup}{self.cols['reset']}\n"
        self._print_length(self._rl)

        topic, topic_len = self._decode_string(self.cols['topic'])

        self._output_text += f"Topic:             ({self.cols['strlen']}length: {topic_len}{self.cols['reset']}) {self.cols['topic']}{topic}{self.cols['reset']}\n"
        if qos == 1 or qos == 2:
            self._decode_mid()
        self._decode_properties()
        self._decode_payload()
        self._get_output_v5()


    def _decode_publish(self):
        if self.args.force_spec is None or self.args.force_spec == 4:
            self._decode_publish_v4()

        if self.args.force_spec is None or self.args.force_spec == 5:
            self._restore_state()
            self._decode_publish_v5()


    def _decode_pubflow_v5(self):
        self._print_length(self._rl)
        self._decode_mid()
        if self._packet is not None and len(self._packet) > 0:
            self._decode_reason_code()
        else:
            self._print_reason_code(0) # implied success by omission
        self._decode_properties()
        self._decode_excess_bytes()
        self._get_output_v5()


    def _decode_pubflow_v4(self):
        self._print_length(self._rl)
        self._decode_mid()
        self._decode_excess_bytes()
        self._get_output_v4()


    def _decode_puback(self):
        if self.args.force_spec is None or self.args.force_spec == 4:
            self._output_hex = f"{self.cols['command']}{self._hdr:02x}{self.cols['reset']} " + self._output_hex
            self._output_text += f"Command:           {self.cols['command']}PUBACK v3.1.1{self.cols['reset']}\n"
            self._print_fixed_header(0x00)
            self._decode_pubflow_v4()

        if self.args.force_spec is None or self.args.force_spec == 5:
            self._restore_state()
            self._output_hex = f"{self.cols['command']}{self._hdr:02x}{self.cols['reset']} " + self._output_hex
            self._output_text += f"Command:           {self.cols['command']}PUBACK v5.0{self.cols['reset']}\n"
            self._print_fixed_header(0x00)
            self._decode_pubflow_v5()


    def _decode_pubrec(self):
        if self.args.force_spec is None or self.args.force_spec == 4:
            self._output_hex = f"{self.cols['command']}{self._hdr:02x}{self.cols['reset']} " + self._output_hex
            self._output_text += f"Command:           {self.cols['command']}PUBREC v3.1.1{self.cols['reset']}\n"
            self._print_fixed_header(0x00)
            self._decode_pubflow_v4()

        if self.args.force_spec is None or self.args.force_spec == 5:
            self._restore_state()
            self._output_hex = f"{self.cols['command']}{self._hdr:02x}{self.cols['reset']} " + self._output_hex
            self._output_text += f"Command:           {self.cols['command']}PUBREC v5.0{self.cols['reset']}\n"
            self._print_fixed_header(0x00)
            self._decode_pubflow_v5()


    def _decode_pubrel(self):
        if self.args.force_spec is None or self.args.force_spec == 4:
            self._output_hex = f"{self.cols['command']}{self._hdr:02x}{self.cols['reset']} " + self._output_hex
            self._output_text += f"Command:           {self.cols['command']}PUBREL v3.1.1{self.cols['reset']}\n"
            self._print_fixed_header(0x00)
            self._decode_pubflow_v4()

        if self.args.force_spec is None or self.args.force_spec == 5:
            self._restore_state()
            self._output_hex = f"{self.cols['command']}{self._hdr:02x}{self.cols['reset']} " + self._output_hex
            self._output_text += f"Command:           {self.cols['command']}PUBREL v5.0{self.cols['reset']}\n"
            self._print_fixed_header(0x00)
            self._decode_pubflow_v5()


    def _decode_pubcomp(self):
        if self.args.force_spec is None or self.args.force_spec == 4:
            self._output_hex = f"{self.cols['command']}{self._hdr:02x}{self.cols['reset']} " + self._output_hex
            self._output_text += f"Command:           {self.cols['command']}PUBCOMP v3.1.1{self.cols['reset']}\n"
            self._print_fixed_header(0x00)
            self._decode_pubflow_v4()

        if self.args.force_spec is None or self.args.force_spec == 5:
            self._restore_state()
            self._output_hex = f"{self.cols['command']}{self._hdr:02x}{self.cols['reset']} " + self._output_hex
            self._output_text += f"Command:           {self.cols['command']}PUBCOMP v5.0{self.cols['reset']}\n"
            self._print_fixed_header(0x00)
            self._decode_pubflow_v5()


    def _decode_subscribe_v4(self):
        self._output_text += f"Command:           {self.cols['command']}SUBSCRIBE v3.1.1{self.cols['reset']}\n"
        self._output_hex = f"{self.cols['command']}{self._hdr:02x}{self.cols['reset']} " + self._output_hex
        self._print_fixed_header(0x02)
        self._print_length(self._rl)
        self._decode_mid()
        while self._rl > 0:
            topic, topic_len = self._decode_string(self.cols['topic'])
            qos = self._decode_byte(self.cols['qos'])
            if isinstance(qos, int) and qos > 2:
                qos = f"{self.cols['error']}3{self.cols['reset']}"
            self._output_text += f"Topic:             ({self.cols['strlen']}length: {topic_len}{self.cols['reset']}) {self.cols['topic']}{topic}{self.cols['reset']}\n"
            self._output_text += f"  QoS:             {self.cols['qos']}{qos}{self.cols['reset']}\n"

        self._decode_excess_bytes()
        self._get_output_v4()


    def _decode_subscribe_v5(self):
        self._output_text += f"Command:           {self.cols['command']}SUBSCRIBE v5.0{self.cols['reset']}\n"
        self._output_hex = f"{self.cols['command']}{self._hdr:02x}{self.cols['reset']} " + self._output_hex
        self._print_fixed_header(0x02)
        self._print_length(self._rl)
        self._decode_mid()
        self._decode_properties()
        while self._rl > 0:
            topic, topic_len = self._decode_string(self.cols['topic'])
            options = self._decode_byte(self.cols['subopt'])
            if isinstance(options, int):
                qos = options & 0x03
                if qos == 3:
                    qos = f"{self.cols['error']}3{self.cols['reset']}"
                self._output_text += f"Topic:             ({self.cols['strlen']}length: {topic_len}{self.cols['reset']}) {self.cols['topic']}{topic}{self.cols['reset']}\n"
                self._output_text += f"  QoS:             {self.cols['qos']}{qos}{self.cols['reset']}\n"
                if options & 0x04:
                    self._output_text += f"  Flags:           {self.cols['subopt']}no-local{self.cols['reset']}\n"
                if options & 0x08:
                    self._output_text += f"  Flags:           {self.cols['subopt']}retain-as-published{self.cols['reset']}\n"
                retain_handling = options & 0x30
                if retain_handling == 0x00:
                    self._output_text += f"  Flags:           {self.cols['subopt']}send-retain-on-subscription{self.cols['reset']}\n"
                elif retain_handling == 0x10:
                    self._output_text += f"  Flags:           {self.cols['subopt']}send-retain-on-new-subscription{self.cols['reset']}\n"
                elif retain_handling == 0x20:
                    self._output_text += f"  Flags:           {self.cols['subopt']}send-retain-never{self.cols['reset']}\n"
                else:
                    self._output_text += f"  Flags:           {self.cols['error']}send-retain-malformed{self.cols['reset']}\n"
                if options & 0xC0:
                    self._output_text += f"  Flags:           {self.cols['error']}Subscription options malformed: {options:02x}{self.cols['reset']}\n"
            else:
                self._output_text += f"Topic:             ({self.cols['strlen']}length: {topic_len}{self.cols['reset']}) {self.cols['topic']}{topic}{self.cols['reset']}\n"
                self._output_text += f"  Flags:           {self.cols['error']}Subscription options malformed: {options}{self.cols['reset']}\n"

        self._decode_excess_bytes()
        self._get_output_v5()


    def _decode_subscribe(self):
        if self.args.force_spec is None or self.args.force_spec == 4:
            self._decode_subscribe_v4()

        if self.args.force_spec is None or self.args.force_spec == 5:
            self._restore_state()
            self._decode_subscribe_v5()


    def _decode_suback_v4(self):
        self._output_text += f"Command:           {self.cols['command']}SUBACK v3.1.1{self.cols['reset']}\n"
        self._output_hex = f"{self.cols['command']}{self._hdr:02x}{self.cols['reset']} " + self._output_hex
        self._print_fixed_header(0x00)
        self._print_length(self._rl)
        self._decode_mid()
        if self._packet is None or len(self._packet) == 0:
            self._output_text += f"Granted Qos:       {self.errstr}\n"
        while self._rl > 0:
            qos = self._decode_byte(self.cols['qos'])
            if isinstance(qos, int) and qos <= 2:
                self._output_text += f"Granted QoS:       {self.cols['qos']}{qos}{self.cols['reset']}\n"
            else:
                self._output_text += f"Granted QoS:       {self.cols['error']}{qos}{self.cols['reset']}\n"
        self._get_output_v4()


    def _decode_suback_v5(self):
        self._output_text += f"Command:           {self.cols['command']}SUBACK v5.0{self.cols['reset']}\n"
        self._output_hex = f"{self.cols['command']}{self._hdr:02x}{self.cols['reset']} " + self._output_hex
        self._print_fixed_header(0x00)
        self._print_length(self._rl)
        self._decode_mid()
        self._decode_properties()
        if self._packet is None or len(self._packet) == 0:
            self._output_text += f"Reason code:       {self.errstr}\n"
        while self._rl > 0:
            byte = self._decode_byte(self.cols['rc'])
            if isinstance(byte, int) and byte <= 2:
                self._output_text += f"Reason code:       {byte}\n"
            else:
                self._print_reason_code(byte)
        self._get_output_v5()


    def _decode_suback(self):
        if self.args.force_spec is None or self.args.force_spec == 4:
            self._decode_suback_v4()

        if self.args.force_spec is None or self.args.force_spec == 5:
            self._restore_state()
            self._decode_suback_v5()


    def _decode_unsubscribe_v4(self):
        self._output_text += f"Command:           {self.cols['command']}UNSUBSCRIBE v3.1.1{self.cols['reset']}\n"
        self._output_hex = f"{self.cols['command']}{self._hdr:02x}{self.cols['reset']} " + self._output_hex
        self._print_fixed_header(0x02)
        self._print_length(self._rl)
        self._decode_mid()
        while self._rl > 0:
            topic, topic_len = self._decode_string(self.cols['topic'])
            self._output_text += f"Topic:             ({self.cols['strlen']}length: {topic_len}{self.cols['reset']}) {self.cols['topic']}{topic}{self.cols['reset']}\n"

        self._decode_excess_bytes()
        self._get_output_v4()


    def _decode_unsubscribe_v5(self):
        self._output_text += f"Command:           {self.cols['command']}UNSUBSCRIBE v5.0{self.cols['reset']}\n"
        self._output_hex = f"{self.cols['command']}{self._hdr:02x}{self.cols['reset']} " + self._output_hex
        self._print_fixed_header(0x02)
        self._print_length(self._rl)
        self._decode_mid()
        self._decode_properties()
        while self._rl > 0:
            topic, topic_len = self._decode_string(self.cols['topic'])
            self._output_text += f"Topic:             ({self.cols['strlen']}length: {topic_len}{self.cols['reset']}) {self.cols['topic']}{topic}{self.cols['reset']}\n"

        self._decode_excess_bytes()
        self._get_output_v5()


    def _decode_unsubscribe(self):
        if self.args.force_spec is None or self.args.force_spec == 4:
            self._decode_unsubscribe_v4()

        if self.args.force_spec is None or self.args.force_spec == 5:
            self._restore_state()
            self._decode_unsubscribe_v5()


    def _decode_unsuback_v4(self):
        self._output_text += f"Command:           {self.cols['command']}UNSUBACK v3.1.1{self.cols['reset']}\n"
        self._output_hex = f"{self.cols['command']}{self._hdr:02x}{self.cols['reset']} " + self._output_hex
        self._print_fixed_header(0x00)
        self._print_length(self._rl)
        self._decode_mid()
        self._decode_excess_bytes()
        self._get_output_v4()


    def _decode_unsuback_v5(self):
        self._output_text += f"Command:           {self.cols['command']}UNSUBACK v5.0{self.cols['reset']}\n"
        self._output_hex = f"{self.cols['command']}{self._hdr:02x}{self.cols['reset']} " + self._output_hex
        self._print_fixed_header(0x00)
        self._print_length(self._rl)
        self._decode_mid()
        self._decode_properties()
        while self._rl > 0:
            self._decode_reason_code()
        self._get_output_v5()


    def _decode_unsuback(self):
        if self.args.force_spec is None or self.args.force_spec == 4:
            self._decode_unsuback_v4()

        if self.args.force_spec is None or self.args.force_spec == 5:
            self._restore_state()
            self._decode_unsuback_v5()


    def _decode_ping(self, label):
        self._output_text += f"Command:           {self.cols['command']}{label} v3.1.1/v5.0{self.cols['reset']}\n"
        self._output_hex = f"{self.cols['command']}{self._hdr:02x}{self.cols['reset']} " + self._output_hex
        self._print_fixed_header(0x00)
        self._print_length(self._rl, 0)
        self._decode_excess_bytes()
        self._get_output_v4()


    def _decode_pingreq(self):
        self._decode_ping("PINGREQ")


    def _decode_pingresp(self):
        self._decode_ping("PINGRESP")


    def _decode_disconnect_v4(self):
        self._output_text += f"Command:           {self.cols['command']}DISCONNECT v3.1.1{self.cols['reset']}\n"
        self._output_hex = f"{self.cols['command']}{self._hdr:02x}{self.cols['reset']} " + self._output_hex
        self._print_fixed_header(0x00)
        self._print_length(self._rl, 0)
        self._decode_excess_bytes()
        self._get_output_v4()


    def _decode_disconnect_v5(self):
        self._output_text += f"Command:           {self.cols['command']}DISCONNECT v5.0{self.cols['reset']}\n"
        self._output_hex = f"{self.cols['command']}{self._hdr:02x}{self.cols['reset']} " + self._output_hex
        self._print_fixed_header(0x00)
        self._print_length(self._rl)
        self._decode_reason_code()
        self._decode_properties()
        self._decode_excess_bytes()
        self._get_output_v5()


    def _decode_disconnect(self):
        if self.args.force_spec is None or self.args.force_spec == 4:
            self._decode_disconnect_v4()

        if self.args.force_spec is None or self.args.force_spec == 5:
            self._restore_state()
            self._decode_disconnect_v5()


    def _decode_auth_v4(self):
        self._output_text += f"Command:           {self.cols['error']}AUTH{self.cols['reset']}\n"
        self._output_hex = f"{self.cols['command']}{self._hdr:02x}{self.cols['reset']} " + self._output_hex
        self._print_length(self._rl)
        self._decode_excess_bytes()
        self._get_output_v4()

    def _decode_auth_v5(self):
        self._output_text += f"Command:           {self.cols['command']}AUTH v5.0{self.cols['reset']}\n"
        self._output_hex = f"{self.cols['command']}{self._hdr:02x}{self.cols['reset']} " + self._output_hex
        self._print_fixed_header(0x00)
        self._print_length(self._rl)
        self._decode_reason_code()
        self._decode_properties()
        self._decode_excess_bytes()
        self._get_output_v5()

    def _decode_auth(self):
        if self.args.force_spec is None or self.args.force_spec == 4:
            self._decode_auth_v4()

        if self.args.force_spec is None or self.args.force_spec == 5:
            self._restore_state()
            self._decode_auth_v5()


    def _decode_packet(self):
        self._output_text = ""
        self._output_text_v4 = ""
        self._output_text_v5 = ""
        self._output_hex = ""
        self._output_hex_v4 = ""
        self._output_hex_v5 = ""
        self._hdr, self._packet = struct.unpack("!B%ds" % (len(self._packet)-1), bytes(self._packet))
        self._rl = 100 # to keep decode_varint happy
        self._rl, _ = self._decode_varint(self.cols['length'])
        self._save_state()

        cmd = self._hdr & 0xF0
        if cmd == 0x00:
            self._decode_reserved()
        elif cmd == 0x10:
            self._decode_connect()
        elif cmd == 0x20:
            self._decode_connack()
        elif cmd == 0x30:
            self._decode_publish()
        elif cmd == 0x40:
            self._decode_puback()
        elif cmd == 0x50:
            self._decode_pubrec()
        elif cmd == 0x60:
            self._decode_pubrel()
        elif cmd == 0x70:
            self._decode_pubcomp()
        elif cmd == 0x80:
            self._decode_subscribe()
        elif cmd == 0x90:
            self._decode_suback()
        elif cmd == 0xA0:
            self._decode_unsubscribe()
        elif cmd == 0xB0:
            self._decode_unsuback()
        elif cmd == 0xC0:
            self._decode_pingreq()
        elif cmd == 0xD0:
            self._decode_pingresp()
        elif cmd == 0xE0:
            self._decode_disconnect()
        elif cmd == 0xF0:
            self._decode_auth()
        return ""

def get_args():
    parser = argparse.ArgumentParser(
        prog="mqttdecoder",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description="Copyright (C) 2024 Roger Light\n\nDecode hex strings of MQTT packets into a human readable form",
        epilog="https://github.com/mqtt-tools/mqttdecode"
    )

    parser.add_argument(
        '-s', "--force-spec", action="store", type=int, default=None,
        choices=[4, 5],
        help="force MQTT protocol version to use: 4 (for v3.1.1), or 5 (for v5.0). Does not apply to CONNECT packets"
    )
    parser.add_argument(
        "--no-colour", action="store_true", default=False,
        help="don't colourise the output"
    )

    parser.add_argument('-f', '--file', type=str, help='file to read strings from')
    parser.add_argument('hex', metavar='hex', type=str, nargs='*', help='a hex string to parse')

    return parser.parse_args()

def check_args(args):
    pass

def main():
    args = get_args()
    check_args(args)

    decoder = mqttdecode(args)

    if sys.stdin.isatty() == False:
        for line in sys.stdin:
            decoder.decode("".join(line))
            print("------------------------------\n")

    if args.file is not None:
        with open(args.file, "rt") as f:
            for line in f:
                decoder.decode("".join(line))
                print("------------------------------\n")

    if len(args.hex) > 0:
        decoder.decode("".join(args.hex))

main()

#!/usr/bin/env python3

# (C) 2024  Roger Light <roger@atchoo.org>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

import argparse
import struct
import sys

ansi_reset = "\u001b[0m"
ansi_error = "\u001b[31;7m"
ansi_red = "\u001b[31m"
ansi_green = "\u001b[32m"
ansi_yellow = "\u001b[33m"
ansi_blue = "\u001b[34m"
ansi_magenta = "\u001b[35m"
ansi_cyan = "\u001b[36m"
ansi_white = "\u001b[37m"
ansi_br_black = "\u001b[90m"
ansi_br_red = "\u001b[91m"
ansi_br_green = "\u001b[92m"
ansi_br_yellow = "\u001b[93m"
ansi_br_blue = "\u001b[94m"
ansi_br_magenta = "\u001b[95m"
ansi_br_cyan = "\u001b[96m"
ansi_br_white = "\u001b[97m"

connack_strings = {
    0: "accepted",
    1: "refused: protocol version",
    2: "refused: identifier rejected",
    3: "refused: server unavailable",
    4: "refused: bad username or password",
    5: "refused: not authorized",
}

reason_code_strings = {
    0: "success",
    4: "disconnect with will message",
    16: "no matching subscribers",
    17: "no subscription existed",
    24: "continue authentication",
    25: "reauthenticate",
    128: "unspecified",
    129: "malformed packet",
    130: "protocol error",
    131: "implementation specific",
    132: "unsupported protocol version",
    133: "clientid not valid",
    134: "bad username or password",
    135: "not authorized",
    136: "server unavailable",
    137: "server busy",
    138: "banned",
    139: "server shutting down",
    140: "bad authentication method",
    141: "keep alive timeout",
    142: "session taken over",
    143: "topic filter invalid",
    144: "topic name invalid",
    145: "packet id in use",
    146: "packet id not found",
    147: "receive maximum exceeded",
    148: "topic alias invalid",
    149: "packet too large",
    150: "message rate too high",
    151: "quota exceeded",
    152: "administrative action",
    153: "payload format invalid",
    154: "retain not supported",
    155: "qos not supported",
    156: "use another server",
    157: "server moved",
    158: "shared subscriptions not supported",
    159: "connection rate exceeded",
    160: "maximum connection time",
    161: "subscription identifiers not supported",
    162: "wildcard subscriptions not supported",
}

all_props = {
   0x01: ("payload-format-indicator", "byte"),
   0x02: ("message-expiry-interval", "uint32"),
   0x03: ("content-type", "string"),
   0x08: ("response-topic", "string"),
   0x09: ("correlation-data", "string"),
   0x0b: ("subscription-identifier", "varint"),
   0x11: ("session-expiry-interval", "uint32"),
   0x12: ("assigned-client-identifier", "string"),
   0x13: ("server-keep-alive", "uint16"),
   0x15: ("authentication-method", "string"),
   0x16: ("authentication-data", "string"),
   0x17: ("request-problem-information", "byte"),
   0x18: ("will-delay-interval", "uint32"),
   0x19: ("request-response-information", "byte"),
   0x1a: ("response-information", "string"),
   0x1c: ("server-reference", "string"),
   0x1f: ("reason-string", "string"),
   0x21: ("receive-maximum", "uint16"),
   0x22: ("topic-alias-maximum", "uint16"),
   0x23: ("topic-alias", "uint16"),
   0x24: ("maximum-qos", "byte"),
   0x25: ("retain-available", "byte"),
   0x26: ("user-property", "stringpair"),
   0x27: ("maximum-packet-size", "uint32"),
   0x28: ("wildcard-subscription-available", "byte"),
   0x29: ("subscription-identifier-available", "byte"),
   0x2a: ("shared-subscription-available", "byte"),
}

# ============================================================
# OUTPUT COLOURS
# ============================================================
topic_colour = ansi_br_yellow
payload_colour = ansi_br_blue
property_colour = ansi_br_blue
clientid_colour = ansi_br_cyan
keepalive_colour = ansi_br_cyan
cleansession_colour = ansi_br_cyan
protover_colour = ansi_br_cyan
rc_colour = ansi_br_cyan
mid_colour = ansi_br_cyan
qos_colour = ansi_br_cyan
username_colour = ansi_br_cyan
password_colour = ansi_br_cyan
retain_colour = ansi_br_cyan
dup_colour = ansi_br_cyan
sub_opt_colour = ansi_br_cyan
rc_colour = ansi_br_cyan

CONNECT_colour = ansi_yellow
WILL_colour = ansi_br_blue
PUBLISH0_colour = ansi_green
PUBLISH1_colour = ansi_br_green
PUBLISH2_colour = ansi_cyan
SUBSCRIBE_colour = ansi_br_yellow
UNSUBSCRIBE_colour = ansi_magenta
PING_colour = ansi_br_black
DISCONNECT_colour = ansi_blue
AUTH_colour = ansi_br_magenta

class mqttdecode():
    def __init__(self, args):
        self.args = args
        pass

    def decode(self, hexstring):
        self._packet = bytes.fromhex(hexstring)
        while self._packet is not None and len(self._packet) > 0:
            cur_packet = self._packet
            self._decode_packet()
            if self._packet is not None:
                cur_packet = cur_packet[0:len(cur_packet)-len(self._packet)]
            #print(f"{cur_packet.hex()}")
            #print(text)

            if self._packet is not None and len(self._packet) > 0:
                print("\n------------------------------")

    def _decode_excess_bytes(self):
        if self._rl == 0:
            return
        if self._packet is not None and len(self._packet) > 0:
            print(f"Excess bytes:      {ansi_error}{self._packet[0:self._rl].hex()}{ansi_reset}")
            self._packet = self._packet[self._rl:]
        self._rl = 0


    def _decode_byte(self):
        if self._rl <= 0:
            return f"{ansi_error}?{ansi_reset}"
        try:
            byte = self._packet[0]
            self._packet = self._packet[1:]
        except (IndexError, TypeError):
            byte = f"{ansi_error}?{ansi_reset}"
        self._rl -= 1
        return byte


    def _decode_uint16(self):
        if self._rl <= 0:
            return f"{ansi_error}?{ansi_reset}"
        try:
            i16 = struct.unpack('!H', self._packet[0:2])[0]
            self._packet = self._packet[2:]
        except (IndexError, struct.error, TypeError):
            i16 = f"{ansi_error}?{ansi_reset}"
        self._rl -= 2
        return i16


    def _decode_uint32(self):
        if self._rl <= 0:
            return f"{ansi_error}?{ansi_reset}"
        try:
            i32 = struct.unpack('!I', self._packet[0:4])[0]
            self._packet = self._packet[4:]
        except (IndexError, struct.error):
            i32 = f"{ansi_error}?{ansi_reset}"
        self._rl -= 4
        return i32


    def _decode_varint(self):
        if self._rl <= 0:
            return f"{ansi_error}?{ansi_reset}", 0
        mult = 1
        varint = 0
        vl = 0
        for i in range(0,4):
            if self._rl <= 0:
                return f"{ansi_error}?{ansi_reset}", vl
            try:
                byte = self._packet[0]
                self._packet = self._packet[1:]
            except IndexError:
                varint = f"{ansi_error}?{ansi_reset}"
                return (varint, vl)
            self._rl -= 1

            vl += 1
            varint += (byte & 127) * mult
            mult *= 128
            if byte & 128 == 0:
                break

        return (varint, vl)


    def _decode_string(self):
        if isinstance(self._rl, str) or self._rl <= 0:
            return f"{ansi_error}?{ansi_reset}"
        slen = self._decode_uint16()
        if isinstance(slen, int):
            if slen == 0:
                return ""
            try:
                slen = min(slen, self._rl)
                s = struct.unpack(f'!{slen}s', self._packet[0:slen])[0]
                self._rl -= slen
                self._packet = self._packet[slen:]
                s = s.decode('utf-8')
                return s
            except (IndexError, struct.error, UnicodeDecodeError):
                s = f"{ansi_error}?{ansi_reset}"
                return s
        else:
            s = f"{ansi_error}?{ansi_reset}"
            return s


    def _decode_properties(self):
        if self._rl <= 0:
            return
        if self._packet is None or len(self._packet) == 0:
            return
        pl, _ = self._decode_varint()
        if pl > self._rl:
            print(f"Properties Length: {ansi_error}{pl} > remaining length{ansi_reset}")
            return
        else:
            print(f"Properties Length: {pl}")
        if not isinstance(pl, int):
            return

        while self._rl > 0 and pl > 0:
            prop, vl = self._decode_varint()
            pl -= vl

            try:
                propdef = all_props[prop]
            except KeyError:
                print(f"Property:          Unknown type: {ansi_error}{prop}{ansi_reset}")
                return 0, None
            print(f"Property:          {property_colour}{prop},{propdef[0]} = ", end="")
            if propdef[1] == "byte":
                v = self._decode_byte()
                pl -= 1
            elif propdef[1] == "uint16":
                v = self._decode_uint16()
                pl -= 2
            elif propdef[1] == "uint32":
                v = self._decode_uint32()
                pl -= 4
            elif propdef[1] == "varint":
                v, vl = self._decode_varint()
                pl -= vl
            elif propdef[1] == "string":
                v = self._decode_string()
                pl -= (len(v) + 2)
            elif propdef[1] == "stringpair":
                k = self._decode_string()
                v = self._decode_string()
                pl -= (len(k) + 2 + len(v) + 2)
                print(f"{k}:", end="")
            print(f"{v}{ansi_reset}")


    def _decode_mid(self):
        mid = self._decode_uint16()
        if isinstance(mid, int) and mid > 0:
            print(f"Packet ID:         {mid_colour}{mid}{ansi_reset}")
        else:
            print(f"Packet ID:         {ansi_error}{mid}{ansi_reset}")


    def _print_fixed_header(self, expected):
        if self._hdr & 0x0F != expected:
            print(f"Fixed header:      {ansi_error}0x{self._hdr:02x}{ansi_reset}")


    def _print_length(self, rl, expected=-1):
        if isinstance(rl, str):
            print(f"Length:            {rl}")
            exit(1)

        if expected == -1 or rl == expected:
            print(f"Length:            {rl}")
        else:
            print(f"Length:            {ansi_error}{rl}{ansi_reset}")


    def _print_reason_code(self, rc):
        try:
            rc_str = reason_code_strings[rc]
        except KeyError:
            rc_str = f"{ansi_error}Invalid reason code{ansi_reset}"
        print(f"Reason code:       {rc_colour}{rc} ({rc_str}){ansi_reset}")


    def _decode_reason_code(self):
        rc = self._decode_byte()
        self._print_reason_code(rc)


    def _decode_reserved(self):
        print(f"\n{ansi_error}RESERVED{ansi_reset}")
        self._print_length(self._rl)
        self._decode_excess_bytes()


    def _decode_connect_v34(self, cs_label):
        flags = self._decode_byte()
        username_flag = (flags & 0x80) == 0x80
        password_flag = (flags & 0x40) == 0x40
        will_retain = (flags & 0x20) == 0x20
        will_qos = (flags & 0x18) >> 3
        will_flag = (flags & 0x04) == 0x04
        clean_session = (flags & 0x02) == 0x02
        reserved = flags & 0x01
        print(f"{flags:02x}")

        keepalive = self._decode_uint16()
        clientid = self._decode_string()
        if will_flag:
            will_topic = self._decode_string()
            will_message = self._decode_string()
        if username_flag:
            username = self._decode_string()
        else:
            username = None
        if password_flag:
            password = self._decode_string()
        else:
            password = None

        print(f"Clean {cs_label}     {cleansession_colour}{clean_session}{ansi_reset}")
        print(f"Keepalive:         {keepalive_colour}{keepalive}{ansi_reset}")
        print(f"Client ID:         {clientid_colour}{clientid}{ansi_reset}")
        if username is not None:
            print(f"Username:          {username_colour}{username}{ansi_reset}")
        if password is not None:
            print(f"Password:          {password_colour}{password}{ansi_reset}")
        if will_flag:
            print("Will:")
            print(f"  Topic:           {topic_colour}{will_topic}{ansi_reset}")
            print(f"  QoS:             {qos_colour}{will_qos}{ansi_reset}")
            print(f"  Retain:          {retain_colour}{will_retain}{ansi_reset}")
            print(f"  Message:         {payload_colour}{will_message}{ansi_reset}")
        if reserved:
            print(f"Malformed connect flags: {ansi_error}{reserved}{ansi_reset}")

        self._decode_excess_bytes()


    def _decode_connect_v3(self, proto_name, rl_start):
        print(f"\n{CONNECT_colour}CONNECT v3.1/v3.0{ansi_reset}")
        self._print_fixed_header(0x00)
        self._print_length(rl_start)
        if proto_name != "MQIsdp":
            print(f"Protocol name:     {ansi_error}{proto_name}{ansi_reset}")
        self._decode_connect_v34("start:  ")


    def _decode_connect_v4(self, proto_name, rl_start):
        print(f"\n{CONNECT_colour}CONNECT v3.1.1{ansi_reset}")
        self._print_fixed_header(0x00)
        self._print_length(rl_start)
        if proto_name != "MQTT":
            print(f"Protocol name:     {ansi_error}{proto_name}{ansi_reset}")
        self._decode_connect_v34("session:")


    def _decode_connect_v5(proto_name, rl_start):
        print(f"\n{CONNECT_colour}CONNECT v5.0{ansi_reset}")
        self._print_fixed_header(0x00)
        self._print_length(rl_start)
        if proto_name != "MQTT":
            print(f"Protocol name:     {ansi_error}{proto_name}{ansi_reset}")

        flags = self._decode_byte()
        username_flag = flags & 0x80
        password_flag = flags & 0x40
        will_retain = (flags & 0x20) == 0x20
        will_qos = (flags & 0x18) >> 3
        will_flag = flags & 0x04
        clean_start = (flags & 0x02) == 0x02
        reserved = flags & 0x01

        keepalive = self._decode_uint16()
        clientid = self._decode_string()
        if will_flag:
            will_topic = self._decode_string()
            will_message = self._decode_string()
        if username_flag:
            username = self._decode_string()
        else:
            username = None
        if password_flag:
            password = self._decode_string()
        else:
            password = None

        print(f"Clean start:       {cleansession_colour}{clean_start}{ansi_reset}")
        print(f"Keepalive:         {keepalive_colour}{keepalive}{ansi_reset}")
        print(f"Client ID:         {clientid_colour}{clientid}{ansi_reset}")
        if username is not None:
            print(f"Username:          {username_colour}{username}{ansi_reset}")
        if password is not None:
            print(f"Password:          {password_colour}{password}{ansi_reset}")
        if will_flag:
            print("Will:")
            print(f"  Topic:           {topic_colour}{will_topic}{ansi_reset}")
            print(f"  QoS:             {qos_colour}{will_qos}{ansi_reset}")
            print(f"  Retain:          {retain_colour}{will_retain}{ansi_reset}")
            print(f"  Message:         {payload_colour}{will_message}{ansi_reset}")
        if reserved:
            print(f"Malformed connect flags: {ansi_error}{reserved}{ansi_reset}")

        self._decode_properties()
        self._decode_excess_bytes()



    def _decode_connect_unknown(self, proto_name, proto_ver, rl_start):
        print(f"\n{CONNECT_colour}CONNECT {ansi_error}unknown{ansi_reset}")
        self._print_fixed_header(0x00)
        self._print_length(rl_start)
        print(f"Protocol name:     {proto_name}")
        print(f"Protocol version:  {proto_ver}")
        self._decode_excess_bytes()


    def _decode_connect(self):
        rl_start = self._rl
        proto_name = self._decode_string()
        proto_ver = self._decode_byte()

        if proto_ver == 5:
            self._decode_connect_v5(proto_name, rl_start)
        elif proto_ver == 4:
            self._decode_connect_v4(proto_name, rl_start)
        elif proto_ver == 3:
            self._decode_connect_v3(proto_name, rl_start)
        else:
            self._decode_connect_unknown(proto_name, proto_ver, rl_start)


    def _decode_connack_v4(self):
        print(f"\n{CONNECT_colour}CONNACK v3.1.1{ansi_reset}")
        self._print_fixed_header(0x00)
        self._print_length(self._rl)

        resv = self._decode_byte()
        if isinstance(resv, int):
            print(f"Session present:   {(resv & 0x01) == 0x01}")
            if resv & 0xFE:
                print(f"Malformed connect acknowledge: {ansi_error}{resv}{ansi_reset}")
        else:
            print(f"Connect acknowledge: {resv}")

        rc = self._decode_byte()
        try:
            rc_str = connack_strings[rc]
        except KeyError:
            rc_str = f"{ansi_error}Invalid return code{ansi_reset}"
        print(f"Return code:       {rc_colour}{rc} ({rc_str}){ansi_reset}")
        self._decode_excess_bytes()


    def _decode_connack_v5(self):
        print(f"\n{CONNECT_colour}CONNACK v5.0{ansi_reset}")
        self._print_fixed_header(0x00)
        self._print_length(self._rl)

        resv = self._decode_byte()
        if isinstance(resv, int):
            print(f"Session present:   {(resv & 0x01) == 0x01}")
            if resv & 0xFE:
                print(f"Malformed connect acknowledge: {ansi_error}{resv}{ansi_reset}")
        else:
            print(f"Connect acknowledge: {resv}")

        rc = self._decode_byte()
        try:
            rc_str = reason_code_strings[rc]
        except KeyError:
            rc_str = f"{ansi_error}Invalid reason code{ansi_reset}"
        print(f"Reason code:       {rc_colour}{rc} ({rc_str}){ansi_reset}")
        self._decode_properties()
        self._decode_excess_bytes()


    def _decode_connack(self):
        if self.args.force_version is None or self.args.force_version == 4:
            self._decode_connack_v4()

        if self.args.force_version is None or self.args.force_version == 5:
            self._decode_connack_v5()


    def _decode_payload(self):
        if self._rl <= 0 or self._packet is None:
            print("Payload:")

        payload = struct.unpack(f"{self._rl}s", self._packet[0:self._rl])[0]
        self._packet = self._packet[self._rl:]
        self._rl = 0
        try:
            p = payload.decode('utf-8')
        except UnicodeDecodeError:
            p = payload.hex()
        print(f"Payload:           {payload_colour}{p}{ansi_reset}")


    def _decode_publish_v4(self):
        if self._hdr & 0x01:
            retain = "retain"
        else:
            retain = "no-retain"
        qos = (self._hdr & 0x06) >> 1
        if self._hdr & 0x08:
            dup = "dup"
        else:
            dup = ""

        if qos == 0:
            col = PUBLISH0_colour
        elif qos == 1:
            col = PUBLISH1_colour
        elif qos == 2:
            col = PUBLISH2_colour
        else:
            col = PUBLISH0_colour
            qos = f"{ansi_error}3{ansi_reset}"

        print(f"\n{col}PUBLISH v3.1.1{ansi_reset}")
        self._print_length(self._rl)

        topic = self._decode_string()

        print(f"Topic:             {topic_colour}{topic}{ansi_reset}")
        print(f"QoS:               {qos_colour}{qos}{ansi_reset}")
        print(f"Flags:             {retain_colour}{retain}{ansi_reset} {dup_colour}{dup}{ansi_reset}")
        if qos == 1 or qos == 2:
            self._decode_mid()

        self._decode_payload()


    def _decode_publish_v5(self):
        if self._hdr & 0x01:
            retain = "retain"
        else:
            retain = "no-retain"
        qos = (self._hdr & 0x06) >> 1
        if self._hdr & 0x08:
            dup = "dup"
        else:
            dup = ""

        if qos == 0:
            col = PUBLISH0_colour
        elif qos == 1:
            col = PUBLISH1_colour
        elif qos == 2:
            col = PUBLISH2_colour
        else:
            col = PUBLISH0_colour
            qos = f"{ansi_error}3{ansi_reset}"

        print(f"\n{col}PUBLISH v5.0{ansi_reset}")
        self._print_length(self._rl)

        topic = self._decode_string()

        print(f"Topic:             {topic_colour}{topic}{ansi_reset}")
        print(f"QoS:               {qos_colour}{qos}{ansi_reset}")
        print(f"Flags:             {retain_colour}{retain}{ansi_reset} {dup_colour}{dup}{ansi_reset}")
        if qos == 1 or qos == 2:
            self._decode_mid()
        self._decode_properties()
        self._decode_payload()


    def _decode_publish(self):
        if self.args.force_version is None or self.args.force_version == 4:
            self._decode_publish_v4()

        if self.args.force_version is None or self.args.force_version == 5:
            self._decode_publish_v5()


    def _decode_pubflow_v5(self):
        self._print_length(self._rl)
        self._decode_mid()
        if len(self._packet) > 0:
            self._decode_reason_code()
        else:
            self._print_reason_code(0) # implied success by omission
        self._decode_properties()
        self._decode_excess_bytes()


    def _decode_pubflow_v4(self):
        self._print_length(self._rl)
        self._decode_mid()
        self._decode_excess_bytes()


    def _decode_puback(self):
        if self.args.force_version is None or self.args.force_version == 4:
            print(f"\n{PUBLISH1_colour}PUBACK v3.1.1{ansi_reset}")
            self._print_fixed_header(0x00)
            self._decode_pubflow_v4()

        if self.args.force_version is None or self.args.force_version == 5:
            print(f"\n{PUBLISH1_colour}PUBACK v5.0{ansi_reset}")
            self._print_fixed_header(0x00)
            self._decode_pubflow_v5()


    def _decode_pubrec(self):
        if self.args.force_version is None or self.args.force_version == 4:
            print(f"\n{PUBLISH2_colour}PUBREC v3.1.1{ansi_reset}")
            self._print_fixed_header(0x00)
            self._decode_pubflow_v4()

        if self.args.force_version is None or self.args.force_version == 5:
            print(f"\n{PUBLISH2_colour}PUBREC v5.0{ansi_reset}")
            self._print_fixed_header(0x00)
            self._decode_pubflow_v5()


    def _decode_pubrel(self):
        if self.args.force_version is None or self.args.force_version == 4:
            print(f"\n{PUBLISH2_colour}PUBREL v3.1.1{ansi_reset}")
            self._print_fixed_header(0x00)
            self._decode_pubflow_v4()

        if self.args.force_version is None or self.args.force_version == 5:
            print(f"\n{PUBLISH2_colour}PUBREL v5.0{ansi_reset}")
            self._print_fixed_header(0x00)
            self._decode_pubflow_v5()


    def _decode_pubcomp(self):
        if self.args.force_version is None or self.args.force_version == 4:
            print(f"\n{PUBLISH2_colour}PUBCOMP v3.1.1{ansi_reset}")
            self._print_fixed_header(0x00)
            self._decode_pubflow_v4()

        if self.args.force_version is None or self.args.force_version == 5:
            print(f"\n{PUBLISH2_colour}PUBCOMP v5.0{ansi_reset}")
            self._print_fixed_header(0x00)
            self._decode_pubflow_v5()


    def _decode_subscribe_v4(self):
        print(f"\n{SUBSCRIBE_colour}SUBSCRIBE v3.1.1{ansi_reset}")
        self._print_fixed_header(0x02)
        self._print_length(self._rl)
        self._decode_mid()
        while self._rl > 0:
            topic = self._decode_string()
            qos = self._decode_byte()
            if isinstance(qos, int) and qos > 2:
                qos = f"{ansi_error}3{ansi_reset}"
            print(f"Topic:             {topic_colour}{topic}{ansi_reset}")
            print(f"  QoS:             {qos_colour}{qos}{ansi_reset}")

        self._decode_excess_bytes()


    def _decode_subscribe_v5(self):
        print(f"\n{SUBSCRIBE_colour}SUBSCRIBE v5.0{ansi_reset}")
        self._print_fixed_header(0x02)
        self._print_length(self._rl)
        self._decode_mid()
        self._decode_properties()
        while self._rl > 0:
            topic = self._decode_string()
            options = self._decode_byte()
            if isinstance(options, int):
                qos = options & 0x03
                if qos == 3:
                    qos = f"{ansi_error}3{ansi_reset}"
                print(f"Topic:             {topic_colour}{topic}{ansi_reset}")
                print(f"  QoS:             {qos_colour}{qos}{ansi_reset}")
                if options & 0x04:
                    print(f"  Flags:           {sub_opt_colour}no-local{ansi_reset}")
                if options & 0x08:
                    print(f"  Flags:           {sub_opt_colour}retain-as-published{ansi_reset}")
                retain_handling = options & 0x30
                if retain_handling == 0x00:
                    print(f"  Flags:           {sub_opt_colour}send-retain-on-subscription{ansi_reset}")
                elif retain_handling == 0x10:
                    print(f"  Flags:           {sub_opt_colour}send-retain-on-new-subscription{ansi_reset}")
                elif retain_handling == 0x20:
                    print(f"  Flags:           {sub_opt_colour}send-retain-never{ansi_reset}")
                else:
                    print(f"  Flags:           {ansi_error}send-retain-malformed{ansi_reset}")
                if options & 0xC0:
                    print(f"  Flags:           {ansi_error}Subscription options malformed: {options:02x}{ansi_reset}")
            else:
                print(f"Topic:             {topic_colour}{topic}{ansi_reset}")
                print(f"  Flags:           {ansi_error}Subscription options malformed: {options}{ansi_reset}")

        self._decode_excess_bytes()


    def _decode_subscribe(self):
        if self.args.force_version is None or self.args.force_version == 4:
            self._decode_subscribe_v4()

        if self.args.force_version is None or self.args.force_version == 5:
            self._decode_subscribe_v5()


    def _decode_suback_v4(self):
        print(f"\n{SUBSCRIBE_colour}SUBACK v3.1.1{ansi_reset}")
        self._print_fixed_header(0x00)
        self._print_length(self._rl)
        self._decode_mid()
        if self._packet is None or len(self._packet) == 0:
            print(f"Granted Qos:       {ansi_error}?{ansi_reset}")
        while self._rl > 0:
            qos = self._decode_byte()
            if isinstance(qos, int) and qos <= 2:
                print(f"Granted QoS:       {qos_colour}{qos}{ansi_reset}")
            else:
                print(f"Granted QoS:       {ansi_error}{qos}{ansi_reset}")


    def _decode_suback_v5(self):
        print(f"\n{SUBSCRIBE_colour}SUBACK v5.0{ansi_reset}")
        self._print_fixed_header(0x00)
        self._print_length(self._rl)
        self._decode_mid()
        self._decode_properties()
        if self._packet is None or len(self._packet) == 0:
            print(f"Reason code:       {ansi_error}?{ansi_reset}")
        while self._rl > 0:
            byte = self._decode_byte()
            if isinstance(byte, int) and byte <= 2:
                print(f"Reason code:       {byte}")
            else:
                self._print_reason_code(byte)


    def _decode_suback(self):
        if self.args.force_version is None or self.args.force_version == 4:
            self._decode_suback_v4()

        if self.args.force_version is None or self.args.force_version == 5:
            self._decode_suback_v5()


    def _decode_unsubscribe_v4(self):
        print(f"\n{SUBSCRIBE_colour}UNSUBSCRIBE v3.1.1{ansi_reset}")
        self._print_fixed_header(0x02)
        self._print_length(self._rl)
        self._decode_mid()
        while self._rl > 0:
            topic = self._decode_string()
            print(f"Topic:             {topic_colour}{topic}{ansi_reset}")

        self._decode_excess_bytes()


    def _decode_unsubscribe_v5(self):
        print(f"\n{SUBSCRIBE_colour}UNSUBSCRIBE v5.0{ansi_reset}")
        self._print_fixed_header(0x02)
        self._print_length(self._rl)
        self._decode_mid()
        self._decode_properties()
        while self._rl > 0:
            topic = self._decode_string()
            print(f"Topic:             {topic_colour}{topic}{ansi_reset}")

        self._decode_excess_bytes()


    def _decode_unsubscribe(self):
        if self.args.force_version is None or self.args.force_version == 4:
            self._decode_unsubscribe_v4()

        if self.args.force_version is None or self.args.force_version == 5:
            self._decode_unsubscribe_v5()


    def _decode_unsuback_v4(self):
        print(f"\n{UNSUBSCRIBE_colour}UNSUBACK v3.1.1{ansi_reset}")
        self._print_fixed_header(0x00)
        self._print_length(self._rl)
        self._decode_mid()
        self._decode_excess_bytes()


    def _decode_unsuback_v5(self):
        print(f"\n{UNSUBSCRIBE_colour}UNSUBACK v5.0{ansi_reset}")
        self._print_fixed_header(0x00)
        self._print_length(self._rl)
        self._decode_mid()
        self._decode_properties()
        while self._rl > 0:
            self._decode_reason_code()


    def _decode_unsuback(self):
        if self.args.force_version is None or self.args.force_version == 4:
            self._decode_unsuback_v4()

        if self.args.force_version is None or self.args.force_version == 5:
            self._decode_unsuback_v5()


    def _decode_ping(self, label):
        print(f"\n{PING_colour}{label} v3.1.1/v5.0{ansi_reset}")
        self._print_fixed_header(0x00)
        self._print_length(self._rl, 0)
        self._decode_excess_bytes()


    def _decode_pingreq(self):
        self._decode_ping("PINGREQ")


    def _decode_pingresp(self):
        self._decode_ping("PINGRESP")


    def _decode_disconnect_v4(self):
        print(f"\n{DISCONNECT_colour}DISCONNECT v3.1.1{ansi_reset}")
        self._print_fixed_header(0x00)
        self._print_length(self._rl, 0)
        self._decode_excess_bytes()


    def _decode_disconnect_v5(self):
        print(f"\n{DISCONNECT_colour}DISCONNECT v5.0{ansi_reset}")
        self._print_fixed_header(0x00)
        self._print_length(self._rl)
        self._decode_reason_code()
        self._decode_properties()
        self._decode_excess_bytes()


    def _decode_disconnect(self):
        if self.args.force_version is None or self.args.force_version == 4:
            self._decode_disconnect_v4()

        if self.args.force_version is None or self.args.force_version == 5:
            self._decode_disconnect_v5()


    def _decode_auth_v4(self):
        print(f"\n{ansi_error}AUTH{ansi_reset}")
        self._print_length(self._rl)
        self._decode_excess_bytes()

    def _decode_auth_v5(self):
        print(f"\n{AUTH_colour}AUTH v5.0{ansi_reset}")
        self._print_fixed_header(0x00)
        self._print_length(self._rl)
        self._decode_reason_code()
        self._decode_properties()
        self._decode_excess_bytes()

    def _decode_auth(self):
        if self.args.force_version is None or self.args.force_version == 4:
            self._decode_auth_v4()

        if self.args.force_version is None or self.args.force_version == 5:
            self._decode_auth_v5()


    def _decode_packet(self):
        self._hdr, self._packet = struct.unpack("!B%ds" % (len(self._packet)-1), bytes(self._packet))
        self._rl = 100 # to keep decode_varint happy
        self._rl, _ = self._decode_varint()

        cmd = self._hdr & 0xF0
        if cmd == 0x00:
            self._decode_reserved()
        elif cmd == 0x10:
            self._decode_connect()
        elif cmd == 0x20:
            self._decode_connack()
        elif cmd == 0x30:
            self._decode_publish()
        elif cmd == 0x40:
            self._decode_puback()
        elif cmd == 0x50:
            self._decode_pubrec()
        elif cmd == 0x60:
            self._decode_pubrel()
        elif cmd == 0x70:
            self._decode_pubcomp()
        elif cmd == 0x80:
            self._decode_subscribe()
        elif cmd == 0x90:
            self._decode_suback()
        elif cmd == 0xA0:
            self._decode_unsubscribe()
        elif cmd == 0xB0:
            self._decode_unsuback()
        elif cmd == 0xC0:
            self._decode_pingreq()
        elif cmd == 0xD0:
            self._decode_pingresp()
        elif cmd == 0xE0:
            self._decode_disconnect()
        elif cmd == 0xF0:
            self._decode_auth()
        return ""

def get_args():
    parser = argparse.ArgumentParser(
        prog="mqttdecoder",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description="Copyright (C) 2024 Roger Light\n\nDecode hex strings of MQTT packets into a human readable form",
        epilog="https://github.com/mqtt-tools/mqttdecode"
    )

    parser.add_argument(
        "--force-version", action="store", type=int, default=None,
        choices=[4, 5],
        help="force MQTT protocol version to use: 4 (for v3.1.1), or 5 (for v5.0). Does not apply to CONNECT packets"
    )

    parser.add_argument('--file', type=str, help='file to read strings from')
    parser.add_argument('hex', metavar='hex', type=str, nargs='*', help='a hex string to parse')

    return parser.parse_args()

def check_args(args):
    if args.force_version is not None:
        if args.force_version == 4:
            pass
        elif args.force_version == 5:
            pass
        else:
            raise ValueError("--force-version must be 4 or 5")

def main():
    args = get_args()
    check_args(args)

    decoder = mqttdecode(args)

    if len(args.hex) > 0:
        decoder.decode("".join(args.hex))

main()
